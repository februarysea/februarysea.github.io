<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python面试题目总结</title>
    <link href="/2021/03/27/Python%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2021/03/27/Python%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>根据<a href="https://github.com/taizilongxu">taizilongxu</a>&#x2F;<a href="https://github.com/taizilongxu/interview_python">interview_python</a>整理，结合自身知识有所修改。</p><hr><h2 id="可变（mutable）对象和不可变（immutable）对象"><a href="#可变（mutable）对象和不可变（immutable）对象" class="headerlink" title="可变（mutable）对象和不可变（immutable）对象"></a>可变（mutable）对象和不可变（immutable）对象</h2><p>在python中，strings, tuples, 和numbers是不可变的对象，而 list, dict, set 等则是可变的对象。</p><p>所以在参数传递过程中，可变对象传递的是一个值，在函数中这个值指向一个新的内存。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a</span>):<br>    a = <span class="hljs-number">2</span><br>fun(a)<br><span class="hljs-built_in">print</span> a  <span class="hljs-comment"># 1</span><br></code></pre></div></td></tr></table></figure><p>不可变对象传递的是对象地址，函数中对不可变对象进行增加、删除等操作就是对原不可变对象进行操作。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = []<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a</span>):<br>    a.append(<span class="hljs-number">1</span>)<br>fun(a)<br><span class="hljs-built_in">print</span> a  <span class="hljs-comment"># [1]</span><br></code></pre></div></td></tr></table></figure><p>在python中，数字属于不可变类型，所以不存在自增的操作，i &#x3D; i+1本质是i指向一个新的内存，存储的是i+1的值，原来的i值被舍弃的过程。 对于小整数[-5, 256]。考虑到小整数可能频繁使用，出于性能考虑，Python使用小整数对象缓冲池<code>small_ints</code>缓存了[-5, 256]的整数，该范围内的整数在Python系统中是共享的。小整数对象在Python启动过程中初始化，这些个小整数对象的<code>ob_refcnt</code>不会改变且永远&gt;0,所以在vm运行过程中不会被销毁，所以起到了缓冲的作用。</p><p>在Python中，一切都是对象，对象比较可以用**<code>==</code><strong>或者</strong><code>is</code>**。</p><p>**<code>==</code>**比较的是两个对象的内容是否相等，默认会调用对象的 <strong><em>*eq*</em>()</strong> 方法。</p><p>**<code>is</code>**比较的是两个对象的 id 是否相等，也就是是否是同一个对象，是否指向同一个内存地址。</p><h2 id="Python方法"><a href="#Python方法" class="headerlink" title="Python方法"></a>Python方法</h2><p>Python有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;executing foo(%s)&quot;</span>%(x)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self,x</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;executing foo(%s,%s)&quot;</span>%(self,x)<br><br><span class="hljs-meta">    @classmethoddef class_foo(<span class="hljs-params">cls,x</span>):</span><br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;executing class_foo(%s,%s)&quot;</span>%(cls,x)<br><br><span class="hljs-meta">    @staticmethoddef static_foo(<span class="hljs-params">x</span>):</span><br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;executing static_foo(%s)&quot;</span>%x<br><br>a=A()<br></code></pre></div></td></tr></table></figure><p>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p><p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p><p><a href="https://www.notion.so/995e12e5f0274271af5e102d6d3caf72">三种方法对比</a></p><h2 id="访问权限与命名的关系"><a href="#访问权限与命名的关系" class="headerlink" title="访问权限与命名的关系"></a>访问权限与命名的关系</h2><p>在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用单个下划线作为开头。</p><p>(1)以单下划线开头，表示这是一个<strong>保护成员</strong>，只有类对象和子类对象自己能访问到这些变量。以单下划线开头的变量和函数被默认当作是内部函数，使用from module improt *时不会被获取，但是使用import module可以获取</p><p>(2)以单下划线结尾仅仅是为了区别该名称与关键词</p><p>(3)双下划线开头，表示为<strong>私有成员</strong>，只允许类本身访问，子类也不行。在文本上被替换为_class__method</p><p>双下划线开头，双下划线结尾。一种约定，Python内部的名字，用来区别其他用户自定义的命名,以防冲突。是一些 Python 的“魔术”对象，表示这是一个特殊成员，例如：定义类的时候，若是添加__init__方法，那么在创建类的实例的时候，实例会自动调用这个方法，一般用来对实例的属性进行初使化，Python不建议将自己命名的方法写为这种形式。</p><p>self在定义时需要定义，但是在调用时会自动传入。</p><p>self的名字并不是规定死的，但是最好还是按照约定是用self</p><p>self总是指调用时的类的实例。</p><h2 id="生成器和迭代器"><a href="#生成器和迭代器" class="headerlink" title="生成器和迭代器"></a>生成器和迭代器</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>L = [x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>L<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>g = (x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>g<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x0000028F8B774200</span>&gt;<br></code></pre></div></td></tr></table></figure><p>通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator。</p><p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params"><span class="hljs-built_in">max</span></span>):<br>    n, a, b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> n &lt; <span class="hljs-built_in">max</span>:<br><span class="hljs-keyword">yield</span> b<br>  a, b = b, a + b<br>    n = n + <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;done&#x27;</span><br></code></pre></div></td></tr></table></figure><p>而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。可以被next()函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。</p><p>这是因为Python的<code>Iterator</code>对象表示的是一个数据流，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p><p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p><h2 id="args-and-kwargs"><a href="#args-and-kwargs" class="headerlink" title="*args and **kwargs"></a>*args and **kwargs</h2><p><code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中,但是<code>*args</code>必须在<code>**kwargs</code>前面。</p><p>用<code>*args</code>和<code>**kwargs</code>只是为了方便并没有强制使用它们。</p><p>当不确定函数里将要传递多少参数时你可以用<code>*args</code>，它可以传递任意数量的参数，以元祖的形式传递。</p><p><code>**kwargs</code>允许使用没有事先定义的参数名，以字典的的形式传递:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">table_things</span>(<span class="hljs-params">**kwargs</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> kwargs.items():<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;&#123;0&#125; = &#123;1&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, value)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>table_things(apple = <span class="hljs-string">&#x27;fruit&#x27;</span>, cabbage = <span class="hljs-string">&#x27;vegetable&#x27;</span>)<br>cabbage = vegetable<br>apple = fruit<br></code></pre></div></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>本质上，装饰器就是一个返回函数的高阶函数。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-comment"># 定义装饰器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*arg, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;starttime:&quot;</span>)<br>        func(*arg, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;stoptime:&quot;</span>)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-comment"># 使用装饰器</span><br><span class="hljs-meta">@test    </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a+b:&quot;</span>,a+b)<br>    <br><span class="hljs-meta">@test</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params">a, b</span>):    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a-b:&quot;</span>,a-b)<br><br>add(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><h2 id="Python中重载"><a href="#Python中重载" class="headerlink" title="Python中重载"></a>Python中重载</h2><p>函数重载主要是为了解决两个问题。</p><ol><li>可变参数类型。</li><li>可变参数个数。</li></ol><p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p><p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p><p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p><p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p><h2 id="new-和-init-的区别"><a href="#new-和-init-的区别" class="headerlink" title="__new__和__init__的区别"></a>__new__和__init__的区别</h2><p><code>__init__</code>方法做的事情是在对象创建好之后初始化变量。真正创建实例的是<code>__new__</code>方法。</p><ol><li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li><li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li><li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</li><li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li></ol><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p><p>在Python中，如果已经导入过的文件再次被重新导入时候，python不会再重新解释一遍，而是选择从内存中直接将原来导入的值拿来用，这就是Python模块导入的特性。</p><ol><li>文件导入</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">s1.py<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;123&quot;</span>)<br><br>v = Foo()<br><span class="hljs-comment">#v是Foo的实例</span><br><br>s2.py<br><span class="hljs-keyword">from</span> s1 <span class="hljs-keyword">import</span> v <span class="hljs-keyword">as</span> v1<br><span class="hljs-built_in">print</span>(v1,<span class="hljs-built_in">id</span>(v1))  <span class="hljs-comment">#&lt;s1.Foo object at 0x0000000002221710&gt; 35788560</span><br><br><span class="hljs-keyword">from</span> s1 <span class="hljs-keyword">import</span> v <span class="hljs-keyword">as</span> v2<br><span class="hljs-built_in">print</span>(v1,<span class="hljs-built_in">id</span>(v2))   <span class="hljs-comment">#&lt;s1.Foo object at 0x0000000002221710&gt; 35788560</span><br><br><span class="hljs-comment">## 两个的内存地址是一样的</span><br><span class="hljs-comment">## 文件加载的时候，第一次导入后，再次导入时不会再重新加载。</span><br></code></pre></div></td></tr></table></figure><ol><li>基于__new__实现</li></ol><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kw</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">&#x27;_instance&#x27;</span>):<br>            cls._instance = <span class="hljs-built_in">object</span>.__new__(cls, *args, **kw)<br>        <span class="hljs-keyword">return</span> cls._instance<br><br>one = Singleton()<br>two = Singleton()<br><br>two.a = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(one.a)<br><span class="hljs-comment">## 3</span><br><span class="hljs-comment">## one和two完全相同,可以用id(), **, is检测</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(one))<br><span class="hljs-comment">## 29097904</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(two))<br><span class="hljs-comment">## 29097904</span><br><span class="hljs-built_in">print</span>(one ** two)<br><span class="hljs-comment">## True</span><br><span class="hljs-built_in">print</span>(one <span class="hljs-keyword">is</span> two)<br></code></pre></div></td></tr></table></figure><h2 id="GIL全局解释器锁"><a href="#GIL全局解释器锁" class="headerlink" title="GIL全局解释器锁"></a>GIL全局解释器锁</h2><p>线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。一个线程有两种情况下会释放全局解释器锁，一种情况是在该线程进入IO操作之前，会主动释放GIL，另一种情况是解释器不间断运行了1000字节码（Py2）或运行15毫秒（Py3）后，该线程也会放弃GIL。</p><p>在Python多线程下，每个线程的执行方式：</p><p>1.获取GIL</p><p>2.执行代码直到sleep或者是python虚拟机将其挂起。</p><p>3.释放GIL</p><h2 id="Python里的拷贝"><a href="#Python里的拷贝" class="headerlink" title="Python里的拷贝"></a>Python里的拷贝</h2><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2667dcdc-b7e8-4c83-b341-bd7311a11b7b/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2667dcdc-b7e8-4c83-b341-bd7311a11b7b/Untitled.png"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/26799a95-9f32-449e-b960-b8264a18f4de/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/26799a95-9f32-449e-b960-b8264a18f4de/Untitled.png"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ee8e66e7-451a-4724-91cd-4364b415819c/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ee8e66e7-451a-4724-91cd-4364b415819c/Untitled.png"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]]  <span class="hljs-comment">#原始对象</span><br><br>b = a  <span class="hljs-comment">#赋值，传对象的引用</span><br>c = copy.copy(a)  <span class="hljs-comment">#对象拷贝，浅拷贝</span><br>d = copy.deepcopy(a)  <span class="hljs-comment">#对象拷贝，深拷贝</span><br><br>a.append(<span class="hljs-number">5</span>)  <span class="hljs-comment">#修改对象a</span><br>a[<span class="hljs-number">4</span>].append(<span class="hljs-string">&#x27;c&#x27;</span>)  <span class="hljs-comment">#修改对象a中的[&#x27;a&#x27;, &#x27;b&#x27;]数组对象</span><br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;a = &#x27;</span>, a<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;b = &#x27;</span>, b<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;c = &#x27;</span>, c<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;d = &#x27;</span>, d<br><br>输出结果：<br>a =  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], <span class="hljs-number">5</span>]<br>b =  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], <span class="hljs-number">5</span>]<br>c =  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br>d =  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]]<br></code></pre></div></td></tr></table></figure><h2 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h2><p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p><p><strong>1 引用计数</strong></p><p>PyObject是每个对象必有的内容，其中<code>ob_refcnt</code>就是做为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt</code>就会减少.引用计数为0时，该对象生命就结束了。</p><p>优点:</p><ol><li>简单</li><li>实时性</li></ol><p>缺点:</p><ol><li>维护引用计数消耗资源</li><li>循环引用</li></ol><p><strong>2 标记-清除机制</strong></p><p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p><p><strong>3 分代技术</strong></p><p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p><p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p><p>举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。</p><h2 id="对面向对象的理解"><a href="#对面向对象的理解" class="headerlink" title="对面向对象的理解"></a>对面向对象的理解</h2><p>面向对象是现实世界模型的自然延伸，这是一种”万物皆对象”的编程思想。在现实生活中的任何物体都可以归为一类事物，而一个个体都是一类事物的实例。</p><p>面向对象有三大特性，封装，继承，多态。</p><p>1、“封装”是面向对象的基础，它让我们能够把现实环境的复杂内容进行归类，让编程无论在理解度上还是在语法上进行更好的表达，使其属性私有化，行为公开化，提高数据的隐秘性的同时，使得代码模块化。这样使得代码的复用性更高。</p><p>2、“继承”表达的是“重复”，是复用性的体现，能够让我们通过找到类型的共性进行更进一步的提取和划分；每一个子类是一个特殊的父类-有父类的行为和属性，也有自己的特有的行为和属性。这样做扩展了已存在的代码块，进一步提高了代码的复用性。</p><p>3、“多态”则是多样性、可扩展性的体现。面对丰富的和可能不断变化的问题域，让我们的程序能够有更大的容纳性去模拟和适应这些变化。简单说多态就是相同的对象调用同样的方法但做了不同的事情。主要的目的是实现接口的可重用性。</p><p>多态的实现主要有两种方式：（1）方法重写，实现运行时的多态。子类继承父类重写父类的方法，父类引用指向子类对象；（2）方法重载，实现编译时的多态。主要通过参数的个数和类型进行方法重载。</p><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>简单来说，lambda表达式通常是当你需要使用一个函数，但是又不想费脑袋去命名一个函数的时候使用，也就是通常所说的匿名函数。</p><p>lambda表达式一般的形式是：关键词lambda后面紧接一个或多个参数，紧接一个冒号“：”，紧接一个表达式。lambda表达式是一个表达式不是一个语句。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">f = <span class="hljs-keyword">lambda</span> a,b: a*b<br></code></pre></div></td></tr></table></figure><h2 id="正则表达式-re库"><a href="#正则表达式-re库" class="headerlink" title="正则表达式 re库"></a>正则表达式 re库</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;^.*$&quot;</span>        <span class="hljs-comment"># ^代表开头，$代表结尾</span><br>re.math()     <span class="hljs-comment"># 从开头开始匹配，不匹配则返回none</span><br>re.search()   <span class="hljs-comment"># 寻找全局，直到找到pattern</span><br>re.sub()      <span class="hljs-comment"># 替换</span><br>re.findall()  <span class="hljs-comment"># 用列表返回所有匹配的对象</span><br>re.finditer() <span class="hljs-comment"># 用迭代器返回所有匹配的对象 </span><br>re.split()    <span class="hljs-comment"># 分割后返回列表</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胶片</title>
    <link href="/2020/10/20/%E8%83%B6%E7%89%87/"/>
    <url>/2020/10/20/%E8%83%B6%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h3 id="胶片的结构"><a href="#胶片的结构" class="headerlink" title="胶片的结构"></a>胶片的结构</h3><p>胶片是由<strong>单层的或多层的感光乳剂</strong>以及<strong>感光乳剂所附着的片基</strong>组成的。彩色胶片有三层主要的感光图层：一层感红，一层感蓝，一层感绿。</p><ul><li>感光乳剂是悬浮在明胶中的光敏感物质卤化银颗粒。</li><li>片基是提供给乳剂一个固体附着物，现代感光胶片片基一般都采用乙酸纤维酯薄膜。</li><li>感蓝层：黄染料，感绿层：品红染料，感红层：青染料。</li></ul><p>光线通过相机射到胶片的乳剂层上，当光线到达卤化银晶体时，这些晶体发生结构性变化，并与邻近也受到光线照射的卤化银晶体相互聚结起来。乳剂层接受到的光量越多，就有越多的晶体聚结在一起；光量越少，晶体的变化和聚结也越少。</p><h3 id="胶片的分类"><a href="#胶片的分类" class="headerlink" title="胶片的分类"></a>胶片的分类</h3><h4 id="“负片”（Negative-Film）"><a href="#“负片”（Negative-Film）" class="headerlink" title="“负片”（Negative Film）"></a>“负片”（Negative Film）</h4><p>“负片”是经曝光和显影加工后得到的影像，其明暗与被摄体相反，其色彩为被摄体的补色。“负片”需要经过印放在照片上才能还原为正像。简单地说，拍摄的胶片冲洗出来以后，所看到的影像是反色的影像，需要经过扩印或放大成照片才能变成与所拍摄景物相同色彩的影像。</p><p>以黑白的片子为例，“负片”的胶片上人的头发是白的，而实际上是白色的衣服在胶片上则显示为黑色。如果是彩色的胶片，则胶片上的颜色与实际景物的颜色是互补的，例如：实际是红色的衣服在胶片上显示为绿色。无论是黑白还是彩色的“负片”，都是摄影最常用到的胶片。日常生活中用普通相机拍照冲洗出来的底片就是“负片”。</p><h4 id="“正片”（Positive-Film）"><a href="#“正片”（Positive-Film）" class="headerlink" title="“正片”（Positive Film）"></a>“正片”（Positive Film）</h4><p>电影摄影机所拍的“负片”经过冲洗和剪接后，先复制为若干拷贝带，再用 Positive Film 翻正，就可以在电影院放映了。“正片”是用于印制照片、幻灯片和电影拷贝的感光胶片的总称，能把底片上的负像印制为正像，使影像的明暗及色彩恢复为与被摄体相同。</p><p>黑白“正片”的感色性仅限于紫蓝色光，彩色“正片”的感色能力比彩色“反片”弱。因此，“正片”很少用于摄影。彩色“正片”用于印制彩色放映拷贝，如电影和幻灯片等。其特点是反差大、灰雾度低、清晰度高、感光度低，而且幻灯片与实际的影响是左右镜像的。</p><h4 id="“反转片”（Reversal-Film）"><a href="#“反转片”（Reversal-Film）" class="headerlink" title="“反转片”（Reversal Film）"></a>“反转片”（Reversal Film）</h4><p>“反转片”有彩色和黑白之分，现在所说的“反转片”其实是 Color Reversal Film，常用于静态摄影。之所以称其为“反转片”是因为其在显影的第一阶段成负像，然后才成彩色染料形成的正像。“反转片”是在拍摄后经过反转冲洗可直接获得正像的一种感光胶片。黑白“反转片”可直接获得影像阴暗程度与被摄体一致的透明片；彩色“反转片”可直接获得色彩与被摄体相同的透明片，其色彩真实鲜艳，但宽容度较小。</p><p>“反转片”由于有高质量的正像效果，被大量用于印刷制版或幻灯片制作，专业摄影师在拍摄广告照片时大多都使用彩色“反转片”。 无论是“负片”、“正片”还是“反转片”，都有黑白胶片和彩色胶片之分。彩色“反转片”用于景物拍摄。经过反转冲洗过程可以直接获得与景物明暗、色彩一致的正像，可直接用于放映和印刷制版。其特点是反差比“负片”大，比“正片”小；宽容度比“负片”小，比“正片”大；最低密度小，片基为无色透明。</p><p>比较分析</p><ul><li><strong>“反转片”</strong>，胶片上的颜色与实际所摄景物是颜色是一致的，可通过幻灯机放映出所拍摄的效果。</li><li><strong>“正片”</strong>是用于其它底片“转印 - 冲洗”后得到的正像；</li><li><strong>“反转片”</strong>是通过“拍摄 - 冲洗”自身直接得到正像。</li><li>可以说“正片”就是一种特殊的“负片”。说得更通俗一点，“正片”类似于相纸，只是相纸的基体材料是不透明的纸基，而“正片”的基体是透明的聚脂纤维、醋酸纤维。</li><li>在实际拍摄过程中，使用“反转片”要比使用“负片”的要求少。因为使用“反转片”时所用的曝光数据一定要正确，否则无法弥补；但使用“负片”时，只要其曝光的数据不超过胶片的宽容度，就可以在扩印或放大时进行色彩校正。所以常常称“反转片”为专业胶卷，当然也有专业的“负片”。由于“反转片”属于专业胶片，所因而肯定比“负片”贵。</li></ul><p>说明：由于“反转片”（Reversal film）亦采正像显影方式，“正片”遂成与负片相对的感光材料总称。</p>]]></content>
    
    
    <categories>
      
      <category>个人兴趣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Photography</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>减脂还是增肌</title>
    <link href="/2020/04/16/%E5%87%8F%E8%84%82%E8%BF%98%E6%98%AF%E5%A2%9E%E8%82%8C/"/>
    <url>/2020/04/16/%E5%87%8F%E8%84%82%E8%BF%98%E6%98%AF%E5%A2%9E%E8%82%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="理论依据"><a href="#理论依据" class="headerlink" title="理论依据"></a>理论依据</h3><p>本来我的计划是先减脂出腹肌再说，从去年12月底到现在也瘦了9kg。但有一句话是这么说来着：</p><blockquote><p>瘦子的腹肌和胖子的胸一样无用。</p></blockquote><p>于是我参考知乎 <a href="zhihu.com/question/27128250">健身到底应该先增肌还是先减脂？还是同时进行？</a>下面的回答，总结如下。</p><p>结论是<strong>有限的科学研究表明，减脂和增肌可以同时进行。</strong>但是有限定条件：</p><ul><li><p>完全没有锻炼基础的新手</p></li><li><p>没有进行系统训练的健身小白</p></li><li><p>脂肪太高的肥胖人士</p></li></ul><p>虽然我之前的假期泡过健身房，但也没有系统训练，所以我觉得鄙人减脂和增肌可以同时进行。</p><p>回答下提到，同时增肌和减脂需要满足如下几个要求：</p><ol><li>小的热量缺口，每周至少减少0.7%的体重（新手体重可能不会变化）</li><li>摄入高蛋白：0.8-1g&#x2F;kg</li><li>确保训练上取得进步</li></ol><h3 id="个人计划"><a href="#个人计划" class="headerlink" title="个人计划"></a>个人计划</h3><h4 id="训练计划"><a href="#训练计划" class="headerlink" title="训练计划"></a>训练计划</h4><p>参考<a href="https://www.zhihu.com/question/22035391">增肌计划中健身一周练六天，每天练不同部位是否合理？</a>回答总结如下。</p><p>分化训练：<strong>分化训练被看成是高级训练</strong>——“这个全新的方法能使各部位的每块肌肉都增加训练强度，并在下一次训练以前使这些肌肉有充足的时间恢复，还使全身各部位的每块肌肉都有充足的训练时间。”</p><table><thead><tr><th align="center">天数</th><th align="center">训练部位</th></tr></thead><tbody><tr><td align="center">第一天</td><td align="center">上肢</td></tr><tr><td align="center">第二天</td><td align="center">下肢</td></tr><tr><td align="center">第三天</td><td align="center">休息</td></tr><tr><td align="center">第四天</td><td align="center">上肢</td></tr><tr><td align="center">第五天</td><td align="center">下肢</td></tr><tr><td align="center">第六天</td><td align="center">休息</td></tr><tr><td align="center">第七天</td><td align="center">休息</td></tr></tbody></table><p>注意：腹部要每天训练</p><p>这种方式是练习两天休息一天，保证所有部位的48小时休息。</p><p>训练日训练60-90分钟</p><p>这是许多人想到的另一件事。一般来说，1-5Rm范围内则更注重于力量的增长。（Rm指你能做的最大重量，比如推一个就没有力气了，那么就是1Rm）<br>在6-12Rm范围内更注重于肌肉的增长。<br>在12+Rm范围内则更注重肌肉耐力的增长。</p><p>如果你想让自己的肌肉更“大”，那么就将每组重复次数保持在每组8-15范围内。如果你可以在没有太多挑战的情况下完成超过15次，那么就可以增加重量或难度。这对于诸如弓步，体重下蹲，俯卧撑，引体向上等动作都是如此。</p><p>不包括热身，则建议每个动作都训练3-5组，组间休息不超过1分钟。对于以上计划，如果觉得训练量有点多，那可以把3组的动作变成2组，组间休息30-40秒。</p><p><strong>上下肢训练篇：</strong><br> <strong>上肢：</strong></p><ol><li><p>热身</p></li><li><p>杠铃卧推（胸部）</p></li><li><p>哑铃卧推（胸部）</p></li><li><p>哑铃推举（肩部）</p></li><li><p>哑铃弯举（肱二头）</p></li><li><p>双杠臂屈伸（肱三头&#x2F;胸部）（考虑替换）</p></li><li><p>杠铃划船（背部）</p></li><li><p>卷腹（核心）</p></li><li><p>拉伸</p></li></ol><p><strong>第二周下肢：</strong></p><ol><li><p>热身</p></li><li><p>硬拉（背部&#x2F;臀部）：手臂完全打直</p></li><li><p>杠铃深蹲（腿部）</p></li><li><p>腿举（腿部）</p></li><li><p>小腿提踵（小腿）（考虑替换）</p></li><li><p>山羊挺身（竖脊肌&#x2F;臀）</p></li><li><p>器械腿弯举（腿部）</p></li><li><p>器械腿屈伸（腿部）</p></li><li><p>拉伸</p></li></ol><h4 id="饮食计划"><a href="#饮食计划" class="headerlink" title="饮食计划"></a>饮食计划</h4><p>根据该网站（<a href="https://tdeecalculator.net/%EF%BC%89%E7%9A%84%E8%AE%A1%E7%AE%97%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%A6%81%E5%A2%9E%E8%82%8C%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%88%91%E7%9A%84%E9%A5%AE%E9%A3%9F%E7%BB%93%E6%9E%84%E5%83%8F%E4%B8%8B%E9%9D%A2%E8%BF%99%E6%A0%B7%E3%80%82">https://tdeecalculator.net/）的计算，如果要增肌的话，我的饮食结构像下面这样。</a></p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8A%E5%8D%8810.14.14.png"></p><p>但是这个表似乎把我的额外活动能量估算的太高了，根据Apple Watch的记录，我的基础代谢率按1700大卡来算比较符合最近的身体状况，活动能量日均600大卡。粗略估算一下要多吃500大卡。即，每天吃2800大卡的食物。</p><p>根据知乎文章（<a href="https://zhuanlan.zhihu.com/p/19813055%EF%BC%89%E5%88%9D%E6%AD%A5%E5%88%B6%E5%AE%9A%E8%AE%AD%E7%BB%83%E5%89%8D%E5%90%8E%E7%9A%84%E9%A5%AE%E9%A3%9F%E8%AE%A1%E5%88%92%E5%A6%82%E4%B8%8B%EF%BC%9A">https://zhuanlan.zhihu.com/p/19813055）初步制定训练前后的饮食计划如下：</a></p><p>训练前：吃2个香蕉</p><p>训练后：立即进食，米饭+肉等</p><p>训练日和非训练日：相同</p><p>其他日常按照薄荷健康APP提供的数据指导进食。</p>]]></content>
    
    
    <categories>
      
      <category>个人兴趣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Health</tag>
      
      <tag>Fitness</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客更换主题icarus过程记录</title>
    <link href="/2020/02/15/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98icarus%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/02/15/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98icarus%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>我的博客之前使用的<a href="https://github.com/litten/hexo-theme-yilia">yilia</a>主题，但这个主题已经很久没有维护了，偶然在Github上闲逛发现了优雅的<a href="https://github.com/ppoffice/hexo-theme-icarus">icarus</a>主题，主题特别酷，也一直在维护，于是我便计划更换主题。下面是整个过程的记录。整个配置过程还参考了<a href="https://removeif.github.io/friend/">@辣椒の酱</a>的博客配置、<a href="https://nave.work/">@Evan</a>的博客。</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>icarus主题是支持多语言的，默认是英语，所以在配置主题的<code>_config.yml</code>之前需要把自己博客目录下的<code>_config.yml</code>更改:</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br></code></pre></div></td></tr></table></figure><p>接下来就是主题的<code>_config.yml</code>：</p><p><code>donate</code>功能如果不用需要直接从<code>_config.yml</code>删除，如果只是注释掉会报错。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Version of the Icarus theme that is currently used</span><br><span class="hljs-attr">version:</span> <span class="hljs-number">2.6</span><span class="hljs-number">.0</span><br><span class="hljs-comment"># Path or URL to the website&#x27;s icon</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">/images/logo.png</span><br><span class="hljs-comment"># Additional HTML meta tags in an array.</span><br><span class="hljs-attr">meta:</span> <br><span class="hljs-comment"># canonical_url of your site</span><br><span class="hljs-attr">canonical_url:</span> <br><span class="hljs-comment"># Path or URL to RSS atom.xml</span><br><span class="hljs-attr">rss:</span> <br><span class="hljs-comment"># Path or URL to the website&#x27;s logo to be shown on the left of the navigation bar or footer</span><br><span class="hljs-attr">logo:</span> <span class="hljs-string">/images/logo.png</span><br><span class="hljs-comment"># Open Graph metadata</span><br><span class="hljs-comment"># https://hexo.io/docs/helpers.html#open-graph</span><br><span class="hljs-attr">open_graph:</span><br>    <span class="hljs-comment"># Facebook App ID</span><br>    <span class="hljs-attr">fb_app_id:</span> <br>    <span class="hljs-comment"># Facebook Admin ID</span><br>    <span class="hljs-attr">fb_admins:</span> <br>    <span class="hljs-comment"># Twitter ID</span><br>    <span class="hljs-attr">twitter_id:</span> <br>    <span class="hljs-comment"># Twitter site</span><br>    <span class="hljs-attr">twitter_site:</span> <br>    <span class="hljs-comment"># Google+ profile link</span><br>    <span class="hljs-attr">google_plus:</span> <br><span class="hljs-comment"># Navigation bar link settings</span><br><span class="hljs-attr">navbar:</span><br>    <span class="hljs-comment"># Navigation bar menu links</span><br>    <span class="hljs-attr">menu:</span><br>        <span class="hljs-string">首页:</span> <span class="hljs-string">/</span><br>        <span class="hljs-string">归档:</span> <span class="hljs-string">/archives</span><br>        <span class="hljs-string">分类:</span> <span class="hljs-string">/categories</span><br>        <span class="hljs-string">标签:</span> <span class="hljs-string">/tags</span><br>    <span class="hljs-comment"># Navigation bar links to be shown on the right</span><br>    <span class="hljs-comment"># links:</span><br>        <span class="hljs-comment"># Download on GitHub:</span><br>            <span class="hljs-comment"># icon: fab fa-github</span><br>            <span class="hljs-comment"># url: &#x27;https://github.com/ppoffice/hexo-theme-icarus&#x27;</span><br><span class="hljs-comment"># Footer section link settings</span><br><span class="hljs-attr">footer:</span><br>    <span class="hljs-comment"># Links to be shown on the right of the footer section</span><br>    <span class="hljs-attr">links:</span><br>        <span class="hljs-attr">Creative Commons:</span><br>            <span class="hljs-attr">icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-creative-commons</span><br>            <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;https://creativecommons.org/&#x27;</span><br>        <span class="hljs-attr">Attribution 4.0 International:</span><br>            <span class="hljs-attr">icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-creative-commons-by</span><br>            <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;https://creativecommons.org/licenses/by/4.0/&#x27;</span><br>        <span class="hljs-attr">Download on GitHub:</span><br>            <span class="hljs-attr">icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-github</span><br>            <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;https://github.com/ppoffice/hexo-theme-icarus&#x27;</span><br><span class="hljs-comment"># Article display settings</span><br><span class="hljs-attr">article:</span><br>    <span class="hljs-comment"># Code highlight settings</span><br>    <span class="hljs-attr">highlight:</span> <br>        <span class="hljs-comment"># Code highlight themes</span><br>        <span class="hljs-comment"># https://github.com/highlightjs/highlight.js/tree/master/src/styles</span><br>        <span class="hljs-attr">theme:</span> <span class="hljs-string">github</span><br>        <span class="hljs-comment"># Show code copying button</span><br>        <span class="hljs-attr">clipboard:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-comment"># Default folding status of the code blocks. Can be &quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot;</span><br>        <span class="hljs-attr">fold:</span> <span class="hljs-string">unfolded</span><br>    <span class="hljs-comment"># Whether to show article thumbnail images</span><br>    <span class="hljs-attr">thumbnail:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># Whether to show estimate article reading time</span><br>    <span class="hljs-attr">readtime:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># Search plugin settings</span><br><span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Search</span><br><span class="hljs-attr">search:</span><br>    <span class="hljs-comment"># Name of the search plugin</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">insight</span><br><span class="hljs-comment"># Comment plugin settings</span><br><span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Comment</span><br><span class="hljs-attr">comment:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">valine</span><br>    <span class="hljs-attr">app_id:</span> <span class="hljs-string">xxxxx</span>           <span class="hljs-comment"># (required) LeanCloud application id</span><br>    <span class="hljs-attr">app_key:</span> <span class="hljs-string">xxxx</span>           <span class="hljs-comment"># (required) LeanCloud application key</span><br>    <span class="hljs-attr">notify:</span> <span class="hljs-literal">false</span>           <span class="hljs-comment"># (optional) receive email notification</span><br>    <span class="hljs-attr">verify:</span> <span class="hljs-literal">true</span>            <span class="hljs-comment"># (optional) show verification code</span><br>    <span class="hljs-attr">placeholder:</span> <span class="hljs-string">欢迎交流♂</span>   <span class="hljs-comment"># (optional) comment box placeholder text</span><br><br><span class="hljs-comment"># Share plugin settings</span><br><span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Share</span><br><span class="hljs-attr">share:</span><br>    <span class="hljs-comment"># Share plugin name</span><br>    <span class="hljs-attr">type:</span> <br><span class="hljs-comment"># Sidebar settings.</span><br><span class="hljs-comment"># Please be noted that a sidebar is only visible when it has at least one widget</span><br><span class="hljs-attr">sidebar:</span><br>    <span class="hljs-comment"># left sidebar settings</span><br>    <span class="hljs-attr">left:</span><br>        <span class="hljs-comment"># Whether the left sidebar is sticky when page scrolls</span><br>        <span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span><br>        <span class="hljs-attr">sticky:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># right sidebar settings</span><br>    <span class="hljs-attr">right:</span><br>        <span class="hljs-comment"># Whether the right sidebar is sticky when page scrolls</span><br>        <span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span><br>        <span class="hljs-attr">sticky:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># Sidebar widget settings</span><br><span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/</span><br><span class="hljs-attr">widgets:</span><br>    <span class="hljs-bullet">-</span><br>        <span class="hljs-comment"># Widget name</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">profile</span><br>        <span class="hljs-comment"># Where should the widget be placed, left or right</span><br>        <span class="hljs-attr">position:</span> <span class="hljs-string">left</span><br>        <span class="hljs-comment"># Author name to be shown in the profile widget</span><br>        <span class="hljs-attr">author:</span> <span class="hljs-string">&quot;februarysea&quot;</span><br>        <span class="hljs-comment"># Title of the author to be shown in the profile widget</span><br>        <span class="hljs-attr">author_title:</span> <span class="hljs-string">&quot;目标是神奇宝贝大师！&quot;</span><br>        <span class="hljs-comment"># Author&#x27;s current location to be shown in the profile widget</span><br>        <span class="hljs-attr">location:</span> <span class="hljs-string">&quot;Shanghai&quot;</span><br>        <span class="hljs-comment"># Path or URL to the avatar to be shown in the profile widget</span><br>        <span class="hljs-attr">avatar:</span>  <span class="hljs-string">&quot;images/back.jpg&quot;</span><br>        <span class="hljs-comment"># Email address for the Gravatar to be shown in the profile widget</span><br>        <span class="hljs-attr">gravatar:</span> <br>        <span class="hljs-comment"># Whether to show avatar image rounded or square</span><br>        <span class="hljs-attr">avatar_rounded:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-comment"># Path or URL for the follow button</span><br>        <span class="hljs-attr">follow_link:</span> <span class="hljs-string">&#x27;mailto:februarysea@outlook.com&#x27;</span><br>        <span class="hljs-comment"># Links to be shown on the bottom of the profile widget</span><br>        <span class="hljs-attr">social_links:</span><br>            <span class="hljs-attr">Github:</span><br>                <span class="hljs-attr">icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-github</span><br>                <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;https://github.com/februarysea&#x27;</span><br>            <span class="hljs-comment"># Facebook:</span><br>                <span class="hljs-comment"># icon: fab fa-facebook</span><br>                <span class="hljs-comment"># url: &#x27;https://facebook.com&#x27;</span><br>            <span class="hljs-attr">Twitter:</span><br>                <span class="hljs-attr">icon:</span> <span class="hljs-string">fab</span> <span class="hljs-string">fa-twitter</span><br>                <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;https://twitter.com/Hunk2333&#x27;</span><br>            <span class="hljs-attr">Weibo:</span><br>                <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;fab fa-weibo&#x27;</span><br>                <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;https://weibo.com/u/7097601356&#x27;</span><br>            <span class="hljs-attr">Instagram:</span><br>                <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;fab fa-instagram&#x27;</span><br>                <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;https://www.instagram.com/hunk233/&#x27;</span><br>            <span class="hljs-comment"># Dribbble:</span><br>                <span class="hljs-comment"># icon: fab fa-dribbble</span><br>                <span class="hljs-comment"># url: &#x27;https://dribbble.com&#x27;</span><br>            <span class="hljs-comment"># RSS:</span><br>                <span class="hljs-comment"># icon: fas fa-rss</span><br>                <span class="hljs-comment"># url: /</span><br>    <span class="hljs-bullet">-</span><br>        <span class="hljs-comment"># Widget name</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">toc</span><br>        <span class="hljs-comment"># Where should the widget be placed, left or right</span><br>        <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-bullet">-</span><br>        <span class="hljs-comment"># Widget name</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">links</span><br>        <span class="hljs-comment"># Where should the widget be placed, left or right</span><br>        <span class="hljs-attr">position:</span> <span class="hljs-string">left</span><br>        <span class="hljs-comment"># Links to be shown in the links widget</span><br>        <span class="hljs-attr">links:</span><br>            <span class="hljs-attr">PPOffice:</span> <span class="hljs-string">&#x27;https://github.com/ppoffice&#x27;</span><br>            <span class="hljs-string">辣椒の酱</span> <span class="hljs-string">:</span> <span class="hljs-string">&#x27;https://removeif.github.io/&#x27;</span><br>            <br>    <span class="hljs-bullet">-</span><br>        <span class="hljs-comment"># Widget name</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">category</span><br>        <span class="hljs-comment"># Where should the widget be placed, left or right</span><br>        <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-bullet">-</span><br>        <span class="hljs-comment"># Widget name</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">tagcloud</span><br>        <span class="hljs-comment"># Where should the widget be placed, left or right</span><br>        <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-comment"># -</span><br>        <span class="hljs-comment"># Widget name</span><br>        <span class="hljs-comment"># type: recent_posts</span><br>        <span class="hljs-comment"># Where should the widget be placed, left or right</span><br>        <span class="hljs-comment"># position: right</span><br>    <span class="hljs-bullet">-</span><br>        <span class="hljs-comment"># Widget name</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">archive</span><br>        <span class="hljs-comment"># Where should the widget be placed, left or right</span><br>        <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-bullet">-</span><br>        <span class="hljs-comment"># Widget name</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">tag</span><br>        <span class="hljs-comment"># Where should the widget be placed, left or right</span><br>        <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br><span class="hljs-comment"># Other plugin settings</span><br><span class="hljs-attr">plugins:</span><br>    <span class="hljs-comment"># Enable page animations</span><br>    <span class="hljs-attr">animejs:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># Enable the lightGallery and Justified Gallery plugins</span><br>    <span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/gallery-plugin/</span><br>    <span class="hljs-attr">gallery:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># Enable the Outdated Browser plugin</span><br>    <span class="hljs-comment"># http://outdatedbrowser.com/</span><br>    <span class="hljs-attr">outdated-browser:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># Enable the MathJax plugin</span><br>    <span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/mathjax-plugin/</span><br>    <span class="hljs-attr">mathjax:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># Show the back to top button on mobile devices</span><br>    <span class="hljs-attr">back-to-top:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># Google Analytics plugin settings</span><br>    <span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Google-Analytics</span><br>    <span class="hljs-attr">google-analytics:</span><br>        <span class="hljs-comment"># Google Analytics tracking id</span><br>        <span class="hljs-attr">tracking_id:</span> <br>    <span class="hljs-comment"># Baidu Analytics plugin settings</span><br>    <span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Baidu-Analytics</span><br>    <span class="hljs-attr">baidu-analytics:</span><br>        <span class="hljs-comment"># Baidu Analytics tracking id</span><br>        <span class="hljs-attr">tracking_id:</span> <br>    <span class="hljs-comment"># Hotjar user feedback plugin</span><br>    <span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Hotjar</span><br>    <span class="hljs-attr">hotjar:</span><br>        <span class="hljs-comment"># Hotjar site id</span><br>        <span class="hljs-attr">site_id:</span> <br>    <span class="hljs-comment"># Show a loading progress bar at top of the page</span><br>    <span class="hljs-attr">progressbar:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># BuSuanZi site/page view counter</span><br>    <span class="hljs-comment"># https://busuanzi.ibruce.info</span><br>    <span class="hljs-attr">busuanzi:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># CDN provider settings</span><br><span class="hljs-comment"># https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/speed-up-your-site-with-custom-cdn/</span><br><span class="hljs-attr">providers:</span><br>    <span class="hljs-comment"># Name or URL of the JavaScript and/or stylesheet CDN provider</span><br>    <span class="hljs-attr">cdn:</span> <span class="hljs-string">jsdelivr</span><br>    <span class="hljs-comment"># Name or URL of the webfont CDN provider</span><br>    <span class="hljs-attr">fontcdn:</span> <span class="hljs-string">google</span><br>    <span class="hljs-comment"># Name or URL of the webfont Icon CDN provider</span><br>    <span class="hljs-attr">iconcdn:</span> <span class="hljs-string">fontawesome</span><br></code></pre></div></td></tr></table></figure><h3 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h3><p>icarus内置了多款评论插件，本来最初使用的是<code>gitalk</code>，但它实际上是通过GitHub的<code>issuse</code>来存储评论数据，而且每写一篇新文章还必须自己手动初始化（虽然有自动化的文章但用的语言我不是很熟悉就没细看）。其他的评论系统有好有坏，最后选择了<code>Valine</code>。以下内容摘自<a href="https://valine.js.org/">https://valine.js.org/</a></p><blockquote><p>如果你想在某个网页或者文章页中使用Valine，请参照以下步骤配置</p><h2 id="获取APP-ID-和-APP-Key"><a href="#获取APP-ID-和-APP-Key" class="headerlink" title="获取APP ID 和 APP Key"></a>获取APP ID 和 APP Key</h2><p>请先<a href="https://leancloud.cn/dashboard/login.html#/signin">登录</a>或<a href="https://leancloud.cn/dashboard/login.html#/signup">注册</a> <code>LeanCloud</code>, 进入<a href="https://leancloud.cn/dashboard/applist.html#/apps">控制台</a>后点击左下角<a href="https://leancloud.cn/dashboard/applist.html#/newapp">创建应用</a>：</p><p><img src="https://i.loli.net/2019/06/21/5d0c995c86fac81746.jpg"></p><p>应用创建好以后，进入刚刚创建的应用，选择左下角的<code>设置</code>&gt;<code>应用Key</code>，然后就能看到你的<code>APP ID</code>和<code>APP Key</code>了：</p><p><img src="https://i.loli.net/2019/06/21/5d0c997a60baa24436.jpg"></p><h2 id="评论数据管理"><a href="#评论数据管理" class="headerlink" title="评论数据管理"></a>评论数据管理</h2><p>由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录<code>Leancloud应用</code>管理。  </p><p>具体步骤：<code>登录</code>&gt;<code>选择你创建的应用</code>&gt;<code>存储</code>&gt;选择Class <code>Comment</code>，然后就可以尽情的发挥你的权利啦(～￣▽￣)～</p><blockquote><p>当然，你也可以配合 <a href="https://github.com/panjunwen">@panjunwen</a> 开发的 <a href="https://github.com/panjunwen/Valine-Admin">Valine-Admin</a> 进行<code>评论数据管理</code></p></blockquote><h2 id="安全域名"><a href="#安全域名" class="headerlink" title="安全域名"></a>安全域名</h2><p>为了你的数据安全，请设置自己的<code>安全域名</code>：</p><p><img src="https://i.loli.net/2019/06/21/5d0c995bddd4f99219.jpg" alt="设置安全域名"></p><p>更多信息请查看<a href="/configuration.html">配置项</a>。</p></blockquote><p>配置完成后在icarus主题下的<code>_config.yml</code>填写相应配置就ok。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">comment:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">valine</span><br>    <span class="hljs-attr">app_id:</span> <span class="hljs-string">xxxxx</span>           <span class="hljs-comment"># (required) LeanCloud application id</span><br>    <span class="hljs-attr">app_key:</span> <span class="hljs-string">xxxx</span>           <span class="hljs-comment"># (required) LeanCloud application key</span><br>    <span class="hljs-attr">notify:</span> <span class="hljs-literal">false</span>           <span class="hljs-comment"># (optional) receive email notification</span><br>    <span class="hljs-attr">verify:</span> <span class="hljs-literal">true</span>            <span class="hljs-comment"># (optional) show verification code</span><br>    <span class="hljs-attr">placeholder:</span> <span class="hljs-string">欢迎交流♂</span>   <span class="hljs-comment"># (optional) comment box placeholder text</span><br><br></code></pre></div></td></tr></table></figure><h3 id="相册功能"><a href="#相册功能" class="headerlink" title="相册功能"></a>相册功能</h3><p>本来一直期待自己的博客应该有一个相册，但是实际上设置好相册功能之后发现图片加载特别慢，所以放弃了。但是还是记录下如何设置。</p><p>Icarus内置了相册功能，只需要把<code>_config.yml</code>作如下设置：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">gallery:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p>然后就可以编辑相册页面了。其实就是<code>md</code>格式的静态页面，需要自己手动添加照片。类似下面这样。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">---<br>date: 2019-07-29 16:28:26<br><br>---<br><br><span class="hljs-quote">&gt; <span class="hljs-strong">**2020**</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;justified-gallery&quot;</span>&gt;</span></span><br><br>![<span class="hljs-string">长久</span>](<span class="hljs-link">../images/long.jpg</span>)<br>![<span class="hljs-string">海鸥</span>](<span class="hljs-link">../images/seagull.jpg</span>)<br>![<span class="hljs-string">树们</span>](<span class="hljs-link">../images/trees.jpg</span>)<br>![<span class="hljs-string">浮生</span>](<span class="hljs-link">../images/life.jpg</span>)<br>![<span class="hljs-string">黄与蓝</span>](<span class="hljs-link">../images/yellowAndBlue.jpg</span>)<br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><br><span class="hljs-quote">&gt; <span class="hljs-strong">**2019**</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;justified-gallery&quot;</span>&gt;</span></span><br><br><br>![<span class="hljs-string">东京与富士山</span>](<span class="hljs-link">../images/fuji.jpg</span>)<br>![<span class="hljs-string">东京塔</span>](<span class="hljs-link">../images/tokyoTower.jpg</span>)<br>![<span class="hljs-string">海岸</span>](<span class="hljs-link">../images/sea.jpg</span>)<br>![<span class="hljs-string">永远</span>](<span class="hljs-link">../images/forever.jpg</span>)<br>![<span class="hljs-string">秋天</span>](<span class="hljs-link">../images/autumn.jpg</span>)<br>![<span class="hljs-string">行人</span>](<span class="hljs-link">../images/walker.jpg</span>)<br>![<span class="hljs-string">红色</span>](<span class="hljs-link">../images/red.jpg</span>)<br>![<span class="hljs-string">轨迹</span>](<span class="hljs-link">../images/track.jpg</span>)<br>![<span class="hljs-string">光</span>](<span class="hljs-link">../images/light.jpg</span>)<br>![<span class="hljs-string">老人们</span>](<span class="hljs-link">../images/theOlders.jpg</span>)<br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><h3 id="及时聊天功能"><a href="#及时聊天功能" class="headerlink" title="及时聊天功能"></a>及时聊天功能</h3><p>参考自<a href="%5Bhttps://nave.work/Hexo%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0-%E4%BA%8C-%E6%B7%BB%E5%8A%A0%E8%B1%86%E7%93%A3%E5%92%8C%E8%81%8A%E5%A4%A9%E6%8F%92%E4%BB%B6.html%5D(https://nave.work/Hexo%E4%B8%BB%E9%A2%98%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0-%E4%BA%8C-%E6%B7%BB%E5%8A%A0%E8%B1%86%E7%93%A3%E5%92%8C%E8%81%8A%E5%A4%A9%E6%8F%92%E4%BB%B6.html)">@Evan</a></p><ol><li><p>首先需要注册 <a href="https://www.tidio.com/">Tidio</a> 账号，根据引导填写应用信息。</p></li><li><p>在个人主页中选择 <code>Channels -&gt; Live Chat -&gt; Integration</code> ,复制 JS 代码[<img src="https://cdn.jsdelivr.net/gh/NavePnow/blog_photo@private/screenshot%202019-11-17%20at%2020.37.55.png" alt="img">](<a href="https://cdn.jsdelivr.net/gh/NavePnow/blog_photo@private/screenshot">https://cdn.jsdelivr.net/gh/NavePnow/blog_photo@private/screenshot</a> 2019-11-17 at 20.37.55.png)</p></li><li><p>修改 &#x2F;layout&#x2F;layout.ejs, 在文件最后插入对应的代码.</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">    &lt;% &#125; %&gt;<br>+    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//code.tidio.co/token.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>其中将<code>token</code>替换成你对应的token即可，接下来可以在 Tidio 控制台的 <code>Channel -&gt; Live chat -&gt; Appearance</code> 中根据提示定制聊天对话框的主题外观和语言包，以适应自己的需求。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>项目记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习（二）逻辑回归</title>
    <link href="/2019/11/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <url>/2019/11/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<p>该系列内容是基于吴恩达老师的<a href="https://www.coursera.org/learn/machine-learning/">机器学习</a>课程笔记。</p><p>参考了<a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes">@fengdu78</a>的课程笔记开源项目。</p><hr><h4 id="分类问题（Classifiction"><a href="#分类问题（Classifiction" class="headerlink" title="分类问题（Classifiction)"></a>分类问题（Classifiction)</h4><p>在分类问题中，要预测的变量 $y$ 是离散的值，将学习一种叫做逻辑回归 (<strong>Logistic Regression</strong>) 的算法，这是目前最流行使用最广泛的一种学习算法。</p><p>在分类问题中，我们尝试预测的是结果是否属于某一个类（例如正确或错误）。分类问题的例子有：判断一封电子邮件是否是垃圾邮件；判断一次金融交易是否是欺诈；之前我们也谈到了肿瘤分类问题的例子，区别一个肿瘤是恶性的还是良性的。</p><p>我们将因变量(<strong>dependent variable</strong>)可能属于的两个类分别称为负向类（<strong>negative class</strong>）和正向类（<strong>positive class</strong>），则因变量$y\in { 0,1 }$ ，其中 0 表示负向类，1 表示正向类。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/f86eacc2a74159c068e82ea267a752f7.png"></p><p>如果我们要用线性回归算法来解决一个分类问题，对于分类， $y$ 取值为 0 或者1，但如果使用的是线性回归，那么函数的输出值可能远大于 1，或者远小于0。所以我们在接下来的要研究的算法就叫做逻辑回归算法，这个算法的性质是：它的输出值永远在0到 1 之间。</p><p>顺便说一下，逻辑回归算法是分类算法，我们将它作为分类算法使用。有时候可能因为这个算法的名字中出现了“回归”使人感到困惑，但逻辑回归算法实际上是一种分类算法，它适用于标签 $y$ 取值<strong>离散</strong>的情况，如：1 0 0 1。</p><h4 id="逻辑回归（Logistic-Regression）"><a href="#逻辑回归（Logistic-Regression）" class="headerlink" title="逻辑回归（Logistic Regression）"></a>逻辑回归（Logistic Regression）</h4><p>根据线性回归模型我们只能预测连续的值，然而对于分类问题，我们需要输出0或1，我们可以预测：</p><p>当${h_\theta}\left( x \right)&gt;&#x3D;0.5$时，预测 $y&#x3D;1$。</p><p>当${h_\theta}\left( x \right)&lt;0.5$时，预测 $y&#x3D;0$ 。</p><p>我们引入一个新的模型，逻辑回归，该模型的输出变量范围始终在0和1之间。 逻辑回归模型的假设是： $h_\theta \left( x \right)&#x3D;g\left(\theta^{T}X \right)$ 其中： $X$ 代表特征向量 $g$ 代表逻辑函数（<strong>logistic function</strong>)是一个常用的逻辑函数为<strong>S</strong>形函数（<strong>Sigmoid function</strong>），公式为： $g\left( z \right)&#x3D;\frac{1} {1+{ {e}^{-z} } }$。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/1073efb17b0d053b4f9218d4393246cc.jpg"></p><p>合起来，我们得到逻辑回归模型的假设：</p><p>对模型的理解： $g\left( z \right)&#x3D;\frac{1} {1+{ {e}^{-z} } }$。</p><p>$h_\theta \left( x \right)$的作用是，对于给定的输入变量，根据选择的参数计算输出<strong>变量&#x3D;1</strong>的可能性（<strong>estimated probablity</strong>）即$h_\theta \left( x \right)&#x3D;P\left( y&#x3D;1|x;\theta \right)$ 例如，如果对于给定的$x$，通过已经确定的参数计算得出$h_\theta \left( x \right)&#x3D;0.7$，则表示有70%的几率$y$为正向类，相应地$y$为负向类的几率为1-0.7&#x3D;0.3。</p><h4 id="代价函数（Cost-Function）"><a href="#代价函数（Cost-Function）" class="headerlink" title="代价函数（Cost Function）"></a>代价函数（Cost Function）</h4><p>对于线性回归模型，我们定义的代价函数是所有模型误差的平方和。理论上来说，我们也可以对逻辑回归模型沿用这个定义，但是问题在于，当我们将${h_\theta}\left( x \right)&#x3D;\frac{1} {1+{e^{-\theta^{T}x} } }$带入到这样定义了的代价函数中时，我们得到的代价函数将是一个非凸函数（<strong>non-convexfunction</strong>）。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/8b94e47b7630ac2b0bcb10d204513810.jpg"></p><p>这意味着我们的代价函数有许多局部最小值，这将影响梯度下降算法寻找全局最小值。</p><p>线性回归的代价函数为：$J\left( \theta \right)&#x3D;\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {\frac{1} {2} { {\left( {h_\theta}\left({x}^{\left( i \right)} \right)-{y}^{\left( i \right)} \right)}^{2} } }$ 。 我们重新定义逻辑回归的代价函数为：$J\left( \theta \right)&#x3D;\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} { {Cost}\left( {h_\theta}\left( {x}^{\left( i \right)} \right),{y}^{\left( i \right)} \right)}$，其中</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/54249cb51f0086fa6a805291bf2639f1.png"></p><p>${h_\theta}\left( x \right)$与 $Cost\left( {h_\theta}\left( x \right),y \right)$之间的关系如下图所示：</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/ffa56adcc217800d71afdc3e0df88378.jpg"></p><p>这样构建的$Cost\left( {h_\theta}\left( x \right),y \right)$函数的特点是：当实际的 $y&#x3D;1$ 且${h_\theta}\left( x \right)$也为 1 时误差为 0，当 $y&#x3D;1$ 但${h_\theta}\left( x \right)$不为1时误差随着${h_\theta}\left( x \right)$变小而变大；当实际的 $y&#x3D;0$ 且${h_\theta}\left( x \right)$也为 0 时代价为 0，当$y&#x3D;0$ 但${h_\theta}\left( x \right)$不为 0时误差随着 ${h_\theta}\left( x \right)$的变大而变大。 将构建的 $Cost\left( {h_\theta}\left( x \right),y \right)$简化如下： $Cost\left( {h_\theta}\left( x \right),y \right)&#x3D;-y\times log\left( {h_\theta}\left( x \right) \right)-(1-y)\times log\left( 1-{h_\theta}\left( x \right) \right)$ 带入代价函数得到： $J\left( \theta \right)&#x3D;\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {[-{ {y}^{(i)} }\log \left( {h_\theta}\left( { {x}^{(i)} } \right) \right)-\left( 1-{ {y}^{(i)} } \right)\log \left( 1-{h_\theta}\left( { {x}^{(i)} } \right) \right)]}$ 即：$J\left( \theta \right)&#x3D;-\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {[{ {y}^{(i)} }\log \left( {h_\theta}\left( { {x}^{(i)} } \right) \right)+\left( 1-{ {y}^{(i)} } \right)\log \left( 1-{h_\theta}\left( { {x}^{(i)} } \right) \right)]}$</p><p>在得到这样一个代价函数以后，我们便可以用梯度下降算法来求得能使代价函数最小的参数了。算法为：</p><p><strong>Repeat</strong> { $\theta_j :&#x3D; \theta_j - \alpha \frac{\partial} {\partial\theta_j} J(\theta)$ (<strong>simultaneously update all</strong> ) }</p><p>所以： $\frac{\partial } {\partial {\theta_{j} } }J\left( \theta \right)&#x3D;\frac{\partial } {\partial {\theta_{j} } }[-\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {[-{ {y}^{(i)} }\log \left( 1+{ {e}^{-{\theta^{T} } { {x}^{(i)} } } } \right)-\left( 1-{ {y}^{(i)} } \right)\log \left( 1+{ {e}^{ {\theta^{T} } { {x}^{(i)} } } } \right)]}]$ $&#x3D;-\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {[-{ {y}^{(i)} }\frac{-x_{j}^{(i)} { {e}^{-{\theta^{T} } { {x}^{(i)} } } } } {1+{ {e}^{-{\theta^{T} } { {x}^{(i)} } } } }-\left( 1-{ {y}^{(i)} } \right)\frac{x_j^{(i)} { {e}^{ {\theta^T} { {x}^{(i)} } } } } {1+{ {e}^{ {\theta^T} { {x}^{(i)} } } } } }]$ $&#x3D;-\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} { {y}^{(i)} }\frac{x_j^{(i)} } {1+{ {e}^{ {\theta^T} { {x}^{(i)} } } } }-\left( 1-{ {y}^{(i)} } \right)\frac{x_j^{(i)} { {e}^{ {\theta^T} { {x}^{(i)} } } } } {1+{ {e}^{ {\theta^T} { {x}^{(i)} } } } }]$ $&#x3D;-\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {\frac{ { {y}^{(i)} }x_j^{(i)}-x_j^{(i)} { {e}^{ {\theta^T} { {x}^{(i)} } } }+{ {y}^{(i)} }x_j^{(i)} { {e}^{ {\theta^T} { {x}^{(i)} } } } } {1+{ {e}^{ {\theta^T} { {x}^{(i)} } } } } }$ $&#x3D;-\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {\frac{ { {y}^{(i)} }\left( 1\text{+} { {e}^{ {\theta^T} { {x}^{(i)} } } } \right)-{ {e}^{ {\theta^T} { {x}^{(i)} } } } } {1+{ {e}^{ {\theta^T} { {x}^{(i)} } } } }x_j^{(i)} }$ $&#x3D;-\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {({ {y}^{(i)} }-\frac{ { {e}^{ {\theta^T} { {x}^{(i)} } } } } {1+{ {e}^{ {\theta^T} { {x}^{(i)} } } } })x_j^{(i)} }$ $&#x3D;-\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {({ {y}^{(i)} }-\frac{1} {1+{ {e}^{-{\theta^T} { {x}^{(i)} } } } })x_j^{(i)} }$ $&#x3D;-\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {[{ {y}^{(i)} }-{h_\theta}\left( { {x}^{(i)} } \right)]x_j^{(i)} }$ $&#x3D;\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {[{h_\theta}\left( { {x}^{(i)} } \right)-{ {y}^{(i)} }]x_j^{(i)} }$</p><p>计算后得到了这个等式： ${\theta_j}:&#x3D;{\theta_j}-\alpha \frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {({h_\theta}({ {x}^{(i)} })-{ {y}^{(i)} }){x_{j} }^{(i)} }$ ，将后面这个式子，在 $i&#x3D;1$ 到 $m$ 上求和，其实就是预测误差乘以$x_j^{(i)}$ ，所以你把这个偏导数项$\frac{\partial } {\partial {\theta_j} }J\left( \theta \right)$放回到原来式子这里，我们就可以将梯度下降算法写作如下形式： ${\theta_j}:&#x3D;{\theta_j}-\alpha \frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {({h_\theta}({ {x}^{(i)} })-{ {y}^{(i)} }){x_{j} }^{(i)} }$</p><p>所以，最终的的梯度下降法：</p><p><strong>Repeat</strong> { $\theta_j :&#x3D; \theta_j - \alpha \frac{1} {m}\sum\limits_{i&#x3D;1}^{m} { {\left( {h_\theta}\left( \mathop{x}^{\left( i \right)} \right)-\mathop{y}^{\left( i \right)} \right)} }\mathop{x}_{j}^{(i)}$ <strong>(simultaneously update all</strong> ) }</p><p>注：虽然得到的梯度下降算法表面上看上去与线性回归的梯度下降算法一样，但是这里的${h_\theta}\left( x \right)&#x3D;g\left( {\theta^T}X \right)$与线性回归中不同，所以实际上是不一样的。另外，在运行梯度下降算法之前，进行特征缩放依旧是非常必要的。</p><h4 id="多类分类问题（Multiclass-Classification-One-vs-all）"><a href="#多类分类问题（Multiclass-Classification-One-vs-all）" class="headerlink" title="多类分类问题（Multiclass Classification_ One-vs-all）"></a>多类分类问题（Multiclass Classification_ One-vs-all）</h4><p>对于之前的一个二元分类问题，我们的数据看起来可能如左图所示，然而对于一个多类分类问题，我们的数据集或许看起来像右图一样。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/54d7903564b4416305b26f6ff2e13c04.png"></p><p>下面将介绍如何进行一对多的分类工作，有时这个方法也被称为”一对余”方法。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/b72863ce7f85cd491e5b940924ef5a5f.png"></p><p>这里的三角形是正样本，而圆形代表负样本。可以这样想，设置三角形的值为1，圆形的值为0，下面我们来训练一个标准的逻辑回归分类器，这样我们就得到一个正边界。</p><p>为了能实现这样的转变，我们将多个类中的一个类标记为正向类（$y&#x3D;1$），然后将其他所有类都标记为负向类，这个模型记作$h_\theta^{\left( 1 \right)}\left( x \right)$。接着，类似地第我们选择另一个类标记为正向类（$y&#x3D;2$），再将其它类都标记为负向类，将这个模型记作 $h_\theta^{\left( 2 \right)}\left( x \right)$,依此类推。 最后我们得到一系列的模型简记为： $h_\theta^{\left( i \right)}\left( x \right)&#x3D;p\left( y&#x3D;i|x;\theta \right)$其中：$i&#x3D;\left( 1,2,3….k \right)$</p><p>最后，在我们需要做预测时，我们将所有的分类机都运行一遍，然后对每一个输入变量，都选择最高可能性的输出变量。</p><p>总之，我们已经把要做的做完了，现在要做的就是训练这个逻辑回归分类器：$h_\theta^{\left( i \right)}\left( x \right)$， 其中 $i$ 对应每一个可能的 $y&#x3D;i$，最后，为了做出预测，我们给出输入一个新的 $x$ 值，用这个做预测。我们要做的就是在我们三个分类器里面输入 $x$，然后我们选择一个让 $h_\theta^{\left( i \right)}\left( x \right)$ 最大的$ i$，即$\mathop{\max}\limits_i,h_\theta^{\left( i \right)}\left( x \right)$。</p><p>现在我们知道了基本的挑选分类器的方法，选择出哪一个分类器是可信度最高效果最好的，那么就可认为得到一个正确的分类，无论$i$值是多少，我们都有最高的概率值，我们预测$y$就是那个值。这就是多类别分类问题，以及一对多的方法，通过这个小方法，我们也可以将逻辑回归分类器用在多类分类的问题上。</p><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><p>到现在为止，我们已经学习了几种不同的学习算法，包括线性回归和逻辑回归，它们能够有效地解决许多问题，但是当将它们应用到某些特定的机器学习应用时，会遇到过拟合(<strong>over-fitting</strong>)的问题，可能会导致它们效果很差。</p><p>如果我们有非常多的特征，我们通过学习得到的假设可能能够非常好地适应训练集（代价函数可能几乎为0），但是可能会不能推广到新的数据。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/72f84165fbf1753cd516e65d5e91c0d3.jpg"></p><p>第一个模型是一个线性模型，欠拟合，不能很好地适应我们的训练集；第三个模型是一个四次方的模型，过于强调拟合原始数据，而丢失了算法的本质：预测新数据。我们可以看出，若给出一个新的值使之预测，它将表现的很差，是过拟合，虽然能非常好地适应我们的训练集但在新输入变量进行预测时可能会效果不好；而中间的模型似乎最合适。</p><p>就以多项式理解，$x$ 的次数越高，拟合的越好，但相应的预测的能力就可能变差。</p><p>问题是，如果我们发现了过拟合问题，应该如何处理？</p><ol><li>丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如<strong>PCA</strong>）</li><li>正则化。 保留所有的特征，但是减少参数的大小（<strong>magnitude</strong>）。</li></ol><h4 id="正则化线性回归"><a href="#正则化线性回归" class="headerlink" title="正则化线性回归"></a>正则化线性回归</h4><p>对于线性回归的求解，我们之前推导了两种学习算法：一种基于梯度下降，一种基于正规方程。</p><p>正则化线性回归的代价函数为：</p><p>$J\left( \theta \right)&#x3D;\frac{1} {2m}\sum\limits_{i&#x3D;1}^{m} {[({ {({h_\theta}({ {x}^{(i)} })-{ {y}^{(i)} })}^{2} }+\lambda \sum\limits_{j&#x3D;1}^{n} {\theta _{j}^{2} })]}$</p><p>如果我们要使用梯度下降法令这个代价函数最小化，因为我们未对$\theta_0$进行正则化，所以梯度下降算法将分两种情形：</p><p>$Repeat$ $until$ $convergence${</p><p> ${\theta_0}:&#x3D;{\theta_0}-a\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {(({h_\theta}({ {x}^{(i)} })-{ {y}^{(i)} })x_{0}^{(i)} })$</p><p> ${\theta_j}:&#x3D;{\theta_j}-a[\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {(({h_\theta}({ {x}^{(i)} })-{ {y}^{(i)} })x_{j}^{\left( i \right)} }+\frac{\lambda } {m} {\theta_j}]$</p><p> $for$ $j&#x3D;1,2,…n$</p><p> }</p><p>对上面的算法中$ j&#x3D;1,2,…,n$ 时的更新式子进行调整可得：</p><p>${\theta_j}:&#x3D;{\theta_j}(1-a\frac{\lambda } {m})-a\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {({h_\theta}({ {x}^{(i)} })-{ {y}^{(i)} })x_{j}^{\left( i \right)} }$ 可以看出，正则化线性回归的梯度下降算法的变化在于，每次都在原有算法更新规则的基础上令$\theta $值减少了一个额外的值。</p><h4 id="正则化逻辑回归"><a href="#正则化逻辑回归" class="headerlink" title="正则化逻辑回归"></a>正则化逻辑回归</h4><p>针对逻辑回归问题，在之前学习过两种优化算法：我们首先学习了使用梯度下降法来优化代价函数$J\left( \theta \right)$，接下来学习了更高级的优化算法，这些高级优化算法需要你自己设计代价函数$J\left( \theta \right)$。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/2726da11c772fc58f0c85e40aaed14bd.png"></p><p>自己计算导数同样对于逻辑回归，我们也给代价函数增加一个正则化的表达式，得到代价函数：</p><p>$J\left( \theta \right)&#x3D;\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {[-{ {y}^{(i)} }\log \left( {h_\theta}\left( { {x}^{(i)} } \right) \right)-\left( 1-{ {y}^{(i)} } \right)\log \left( 1-{h_\theta}\left( { {x}^{(i)} } \right) \right)]}+\frac{\lambda } {2m}\sum\limits_{j&#x3D;1}^{n} {\theta _{j}^{2} }$</p><p>要最小化该代价函数，通过求导，得出梯度下降算法为：</p><p>$Repeat$ $until$ $convergence${</p><p> ${\theta_0}:&#x3D;{\theta_0}-a\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {(({h_\theta}({ {x}^{(i)} })-{ {y}^{(i)} })x_{0}^{(i)} })$</p><p> ${\theta_j}:&#x3D;{\theta_j}-a[\frac{1} {m}\sum\limits_{i&#x3D;1}^{m} {({h_\theta}({ {x}^{(i)} })-{ {y}^{(i)} })x_{j}^{\left( i \right)} }+\frac{\lambda } {m} {\theta_j}]$</p><p> $for$ $j&#x3D;1,2,…n$</p><p> }</p><p>注意：</p><ol><li>虽然正则化的逻辑回归中的梯度下降和正则化的线性回归中的表达式看起来一样，但由于两者的${h_\theta}\left( x \right)$不同所以还是有很大差别。</li><li>${\theta_{0} }$不参与其中的任何一个正则化。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于计算机网络的一些知识</title>
    <link href="/2019/11/09/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
    <url>/2019/11/09/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>近日实习遇到了一些不太了解的问题，现搜索并记录如下。网上查阅资料的过程中发现下面的问题基本都能在《HTTP权威指南》这本书上找到，有时间还是系统的阅读一下这本书比较好，对HTTP才能有更深刻全面的理解。</p><hr><h3 id="GET和POST的区别以及联系"><a href="#GET和POST的区别以及联系" class="headerlink" title="GET和POST的区别以及联系"></a>GET和POST的区别以及联系</h3><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><ul><li><p>代理服务器（Proxy Server）是网上提供转接功能的服务器，在一般情况下，我们使用网络浏览器直接去连接其他Internet站点取得网络信息时，是直接联系到目的站点服务器，然后由目的站点服务器把信息传送回来。代理服务器是介于客户端和Web服务器之间的另一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。比如你想访问的目的网站是A，由于某种原因你不能访问到网站A或者你不想直接访问网站A（这样通过代理服务器网站A，对网站A而已可以隐藏你自己的身份，也就是不知道是谁访问的网站，而认为是代理服务器访问的），此时你就可以使用代理服务器，在实际访问网站的时候，你在浏览器的地址栏内和你以前一样输入你要访问的网站，浏览器会自动先访问代理服务器，然后代理服务器会自动给你转接到你的目标网站。</p></li><li><p>代理服务器的作用</p><p>提高访问速度：通常代理服务器都设置一个较大的缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。</p><p>隐藏真实身份：上网者也可以通过代理服务器隐藏自己的真实地址信息，还可隐藏自己的IP，防止被黑客攻击。</p><p>突破限制：有时候网络供应商会对上网用户的端口，目的网站，协议，游戏，即时通讯软件等的限制，使用代理服务器都可以突破这些限制。</p></li><li><p>代理服务器的主要类型</p><p>  1）Http 代理：代理客户机的 http 访问，主要代理浏览器访问网页，它的端口一般为 80、8080、3128 等。<br>  2）SSL 代理:支持最高 128 位加密强度的 http 代理，可以作为访问加密网站的代理。加密网站是指以 https:&#x2F;&#x2F;开始的网站。ssl 的标准端口为 443。<br>  3）HTTP CONNECT 代理：允许用户建立 TCP 连接到任何端口的代理服务器，这种代理不仅可用于 HTTP，还包括 FTP、IRC、RM 流服务等。<br>  4）FTP 代理：代理客户机上的 ftp 软件访问 ftp 服务器，其端口一般为 21、2121。<br>  5）POP3 代理：代理客户机上的邮件软件用 pop3 方式收邮件，其端口一般为 110。<br>  6）Telnet 代理：能够代理通信机的 telnet，用于远程控制，入侵时经常使用。其端口一般为 23。<br>  7）Socks 代理：是全能代理，就像有很多跳线的转接板，它只是简单地将一端的系统连接到另外一端。支持多种协议，包括 http、ftp 请求及其它类型的请求。它分socks 4 和 socks 5 两种类型，socks 4 只支持 TCP 协议而 socks 5 支持 TCP&#x2F;UDP 协议，还支持各种身份验证机制等协议。其标准端口为 1080。</p></li></ul><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>看到知乎<a href="https://www.zhihu.com/question/22577025">回答</a>的通俗解释：</p><p>ip能锁定一台物理机器，对应着一张网卡，外界发来的数据包网卡都会接收。但是问题来了，网卡给程序提供了接口，你监听一下我，要是有消息来了，我就转发给你。这样应用程序就能收到数据了。但是问题来了，程序A和程序B都需要监听网卡接发数据，网卡说那我把接到的数据都发给你两，你们自己看着办吧。好，小A小B都接受了。但是又来了CDEF……，不行了，每个包都被发到了所有应用程序，每个应用程序都累得不行，最终垮了。</p><p>好，那网卡说我给你们加个表示吧，我们之间可以用一个号码来作为标识，我和小A之间就用1来标识，如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD…都自己弄一个标识号，只要不重复就行。这样大家都省事了。<br>最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。这个标识号就是端口。</p><p>端口大小为：0～$2^{16}$(65535)，常用端口如下所示：</p><table><thead><tr><th align="left">端口</th><th align="left">服务</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">21</td><td align="left">FTP</td><td align="left">FTP 服务器所开放的端口，用于上传、下载</td></tr><tr><td align="left">22</td><td align="left">SSH</td><td align="left">22 端口就是 ssh 端口，用于通过命令行模式远程连接 Linux 系统服务器</td></tr><tr><td align="left">25</td><td align="left">SMTP</td><td align="left">SMTP 服务器所开放的端口，用于发送邮件</td></tr><tr><td align="left">80</td><td align="left">HTTP</td><td align="left">用于网站服务例如 IIS、Apache、Nginx 等提供对外访问</td></tr><tr><td align="left">110</td><td align="left">POP3</td><td align="left">110 端口是为 POP3（邮件协议 3）服务开放的</td></tr><tr><td align="left">137&#x2F;138&#x2F;139</td><td align="left">NETBIOS</td><td align="left">其中 137、138 是 UDP 端口，当通过网上邻居传输文件时用这个端口。而 139 端口：通过这个端口进入的连接试图获得 NetBIOS&#x2F;SMB 服务。这个协议被用于 windows 文件和打印机共享和 SAMBA</td></tr><tr><td align="left">143</td><td align="left">IMAP</td><td align="left">143 端口主要是用于“Internet Message AccessProtocol”v2（Internet 消息访问协议，简称 IMAP），和 POP3 一样，是用于电子邮件的接收的协议</td></tr><tr><td align="left">443</td><td align="left">HTTPS</td><td align="left">网页浏览端口，能提供加密和通过安全端口传输的另一种 HTTP</td></tr><tr><td align="left">1433</td><td align="left">SQL Server</td><td align="left">1433 端口，是 SQL Server 默认的端口，SQL Server 服务使用两个端口：TCP-1433、UDP-1434。其中 1433 用于供 SQL Server 对外提供服务，1434 用于向请求者返回 SQL Server 使用了哪个 TCP&#x2F;IP 端口</td></tr><tr><td align="left">3306</td><td align="left">MySQL</td><td align="left">3306 端口，是 MySQL 数据库的默认端口，用于 MySQL 对外提供服务</td></tr><tr><td align="left">3389</td><td align="left">Windows Server Remote Desktop Services</td><td align="left">3389 端口是 Windows 远程桌面的服务端口，可以通过这个端口，用 “远程桌面” 等连接工具来连接到远程的服务器</td></tr><tr><td align="left">8080</td><td align="left">代理端口</td><td align="left">8080 端口同 80 端口，是被用于 WWW 代理服务的，可以实现网页浏览，经常在访问某个网站或使用代理服务器的时候，会加上 “:8080” 端口号。另外 Apache Tomcat web server 安装后，默认的服务端口就是 8080</td></tr></tbody></table><h3 id="ASCII、Unicode、UTF-8、GB2312、GBK"><a href="#ASCII、Unicode、UTF-8、GB2312、GBK" class="headerlink" title="ASCII、Unicode、UTF-8、GB2312、GBK"></a>ASCII、Unicode、UTF-8、GB2312、GBK</h3><ol><li><p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p></li><li><p>Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。具体的符号对应表，可以查询<a href="http://www.unicode.org/">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm">汉字对应表</a>。</p><p>需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p></li><li><p>UTF-8 是 Unicode 的实现方式之一。</p><p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p><p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p></li><li><p>字符必须编码后才能被计算机处理。计算机使用的默认编码方式就是计算机的内码。早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。</p><p>GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94&#x3D;6768。其中有5个空位是D7FA-D7FE。</p><p>GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。</p><p>从ASCII、GB2312到GBK，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。</p></li></ol><h3 id="HTM与HTML的区别"><a href="#HTM与HTML的区别" class="headerlink" title="HTM与HTML的区别"></a>HTM与HTML的区别</h3><p>HTM与HTML没有本质意义的区别，只是为了满足DOS仅能识别8+3的文件名而已，因为一些老的系统(win32)不能识别四位文件名，所以某些网页服务器要求index.html最后一个l不能省略。MSIE能自动识别和打开这些文件，但编写网页地址的时候必须是完全对应的，也就是说index.htm和index.html是两个不同的文件，对应着不同的地址。值得一提的是UNIX系统中对大小写敏感，不吻合的话就可能报没有文件或者找不到文件。</p><p>简单可以理解如下：</p><ol><li>.htm<code>与</code>.htm<code>没有本质上的区别，表示的是同一种文件，只是适用于不同的环境之下。</code></li><li>DOS仅能识别8+3的文件名，所以<code>.htm</code>的命名方法可以被DOS识别，而<code>.html</code>的文件命名方式不能被之识别。</li><li>如果在网页中同时存在<code>index.html</code>与<code>index.htm</code>，这是浏览器将先解释<code>index.html</code>。</li></ol><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>下面是常见的HTTP状态码：</p><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>HTTP状态码列表:</p><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="left">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="left">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成微博词云</title>
    <link href="/2019/10/30/%E7%94%9F%E6%88%90%E5%BE%AE%E5%8D%9A%E8%AF%8D%E4%BA%91/"/>
    <url>/2019/10/30/%E7%94%9F%E6%88%90%E5%BE%AE%E5%8D%9A%E8%AF%8D%E4%BA%91/</url>
    
    <content type="html"><![CDATA[<p>今天花了一天写了一个新浪微博的爬虫，爬取微博指定用户微博内容，然后生成词云，以<a href="%5Bhttps://weibo.com/u/3176010690?from=feed&loc=at&nick=%E5%B8%A6%E5%B8%A6%E5%A4%A7%E5%B8%88%E5%85%84&is_all=1%5D(https://weibo.com/u/3176010690?from=feed&loc=at&nick=%E5%B8%A6%E5%B8%A6%E5%A4%A7%E5%B8%88%E5%85%84&is_all=1)">@带带大师兄</a>为例，这是带带大师兄微博的图云。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/%E5%B8%A6%E5%B8%A6%E5%A4%A7%E5%B8%88%E5%85%84.png"></p><p>具体实现思路是：手机端网页的微博内容比较容易获取，于是通过爬虫访问手机端微博网页<code>m.weibo.com</code>获取某人的微博信息，然后将微博信息构成一个字符串进行词语分割，最后用分割的词语生成词云。</p><ul><li><p>构建请求头：主要是为了微博把我们的爬虫识别为浏览器。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">headers = &#123;<br>            <span class="hljs-string">&#x27;Host&#x27;</span>: <span class="hljs-string">&quot;m.weibo.cn&quot;</span>,<br>            <span class="hljs-string">&#x27;Referer&#x27;</span>: <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>,<br>            <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;</span>,<br>            <span class="hljs-string">&#x27;X-Requested-With&#x27;</span>: <span class="hljs-string">&quot;XMLHttpRequest&quot;</span>,<br>        &#125;<br></code></pre></div></td></tr></table></figure></li><li><p>构建具体链接</p><p>以带带大师兄为例，在他的微博页面向下滑动，打开开发者工具界面，可以看到不断有<code>XHR</code>链接被请求，这样我们就得到了带带大师兄微博真正请求链接。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/Screen%20Shot%202019-10-31%20at%2010.15.55%20AM.png"></p><p>分析链接不难得到有<code>type</code>、<code>uid</code>、<code>containerid</code>这几个参数，如果看后面的XHR请求的话还有<code>page</code>这个参数，于是我们的请求参数构建如下所示：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">params = &#123;<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uid&quot;</span>,<br>    <span class="hljs-string">&quot;value&quot;</span>: uid,<br>    <span class="hljs-string">&quot;containerid&quot;</span>: containerid,<br>  <span class="hljs-string">&quot;page&quot;</span>: <span class="hljs-number">1</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>不难发现<code>uid</code>就是微博主页链接中后面的一串数字，<code>containerid</code>其实就是<code>10763+uid</code>，所以我们的请求构建如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"> containerid = <span class="hljs-built_in">str</span>(<span class="hljs-number">107603</span>) + uid<br> params = &#123;<br>     <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uid&quot;</span>,<br>     <span class="hljs-string">&quot;value&quot;</span>: uid,<br>     <span class="hljs-string">&quot;containerid&quot;</span>: containerid,<br>   <span class="hljs-string">&quot;page&quot;</span>: <span class="hljs-number">1</span><br> &#125;<br>baseUrl = <span class="hljs-string">&quot;https://m.weibo.cn/api/container/getIndex?&quot;</span> + urlencode(params)<br></code></pre></div></td></tr></table></figure><p>这里使用了<code>urlencode</code>是<code>urllib.parse </code>库的一个函数，它将参数编码为符合访问规则的URL。我们最后得到的URL：<code>    https://m.weibo.cn/api/container/getIndex?type=uid&amp;value=3176010690&amp;containerid=1076033176010690&amp;page=1</code></p></li><li><p>获取微博内容</p><p>在这里通过分析请求返回的<code>json</code>内容，不难得到微博内容是在<code>card[&#39;mblog&#39;][&#39;text&#39;]</code>中，通过json库的解析，获得具体的微博内容，然后针对处理各种情况进行一个不太严谨的过滤，就得到了我们想要的微博内容，并把所有内容构建成一个字符串，当然这里也可以逐条存储到数据库中，因为这里微博量不大，就没有这么做。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 获取微博内容</span><br><span class="hljs-keyword">try</span>:<br>    time.sleep(random.random() * <span class="hljs-number">3</span>)  <span class="hljs-comment"># 随机延时0-3s</span><br>    response = requests.get(url, headers=headers)<br>    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>        json = response.json()<br>        cards = json[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;cards&#x27;</span>]<br>        <span class="hljs-keyword">for</span> card <span class="hljs-keyword">in</span> cards:<br>            <span class="hljs-keyword">try</span>:<br>                text = card[<span class="hljs-string">&#x27;mblog&#x27;</span>][<span class="hljs-string">&#x27;text&#x27;</span>]<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error: &quot;</span>, e)<br>                <span class="hljs-keyword">continue</span><br>  <br>            <span class="hljs-comment">#  未显示完全的情况</span><br>            match = re.search(pattern=<span class="hljs-string">&quot;&lt;a href=\&quot;/status/[0-9]+\&quot;&gt;全文&lt;/a&gt;&quot;</span>, string=text)<br>            <span class="hljs-keyword">if</span> match:<br>                reMatch = re.search(pattern=<span class="hljs-string">&quot;[0-9]+&quot;</span>, string=match.group(<span class="hljs-number">0</span>))<br>                params = &#123;<br>                    <span class="hljs-string">&quot;id&quot;</span>: reMatch.group(<span class="hljs-number">0</span>)<br>                &#125;<br>                url = <span class="hljs-string">&quot;https://m.weibo.cn/statuses/extend?&quot;</span> + urlencode(params)<br>                <span class="hljs-keyword">try</span>:<br>                    time.sleep(random.random() * <span class="hljs-number">3</span>)  <span class="hljs-comment"># 随机延时0-3s</span><br>                    response = requests.get(<br>                        url=url,<br>                        headers=headers)<br>                    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>                        json = response.json()<br>                        text = json[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;longTextContent&#x27;</span>]<br>                <span class="hljs-keyword">except</span> requests.ConnectionError <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error&quot;</span>, e.args)<br>  <br>            <span class="hljs-comment"># 过滤空行</span><br>            text = re.sub(pattern=<span class="hljs-string">&quot;&lt;br /&gt;|&lt;span.*&gt;&quot;</span>, repl=<span class="hljs-string">&quot;&quot;</span>, string=text)<br>            <span class="hljs-comment"># 过滤投票</span><br>            text = re.sub(pattern=<span class="hljs-string">&quot;\u6211\u53c2\u4e0e.*&quot;</span>, repl=<span class="hljs-string">&quot;&quot;</span>, string=text)<br>            <span class="hljs-comment"># 过滤围观问答</span><br>            text = re.sub(pattern=<span class="hljs-string">&quot;\u6211\u514d\u8d39\u56f4\u89c2\u4e86.*&quot;</span>, repl=<span class="hljs-string">&quot;&quot;</span>, string=text)<br>            <span class="hljs-comment"># 过滤链接/话题</span><br>            text = re.sub(pattern=<span class="hljs-string">&quot;&lt;a .*&gt;&quot;</span>, repl=<span class="hljs-string">&quot;&quot;</span>, string=text)<br>  <br>            <span class="hljs-comment"># 过滤转发微博/分享图片/经之前过滤成为空行的内容</span><br>            <span class="hljs-keyword">if</span> text == <span class="hljs-string">&quot;转发微博&quot;</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">elif</span> text == <span class="hljs-string">&quot;分享图片 &quot;</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">elif</span> text == <span class="hljs-string">&quot; &quot;</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">elif</span> text ==<span class="hljs-string">&quot;&quot;</span>:<br>                <span class="hljs-keyword">continue</span><br>            text = re.sub(pattern=<span class="hljs-string">&quot; *&quot;</span>, repl=<span class="hljs-string">&quot;&quot;</span>, string=text)<br>            self.words = self.words + text<br>            <span class="hljs-built_in">print</span>(text)<br><span class="hljs-keyword">except</span> requests.ConnectionError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Error&#x27;</span>, e.args)<br></code></pre></div></td></tr></table></figure></li><li><p>生成词云</p><p>针对获得的内容，使用<code>jieba</code>库进行中文词意的分割，然后调用用<code>wordcloud</code>库即可生成词云。</p><p>这两个库具体的使用还是得看他们的文档，我在这里也就不具体说明了。</p><p>jieba:<a href="https://github.com/fxsjy/jieba">https://github.com/fxsjy/jieba</a></p><p>word_cloud:<a href="https://github.com/amueller/word_cloud">https://github.com/amueller/word_cloud</a></p><p>有一点要注意的是，对于中文词云的生成<code>font_path=&quot;simfang.ttf&quot;</code>,这一行一定不能少，否则无法生成。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 精确模式分割</span><br>text = jieba.cut(self.words)<br><span class="hljs-comment"># 空格分词</span><br>text = <span class="hljs-string">&quot; &quot;</span>.join(text)<br><span class="hljs-comment"># 生成词云</span><br>wordcloud = WordCloud(<br>    background_color=<span class="hljs-string">&quot;white&quot;</span>,<br>    font_path=<span class="hljs-string">&quot;simfang.ttf&quot;</span>,<br>    width=<span class="hljs-number">800</span>,<br>    height=<span class="hljs-number">600</span>)<br>wordcloud.generate(text)<br>wordcloud.to_file(<span class="hljs-string">&quot;result/&quot;</span>+self.user+<span class="hljs-string">&quot;.png&quot;</span>)<br>plt.imshow(wordcloud)<br>plt.axis(<span class="hljs-string">&quot;off&quot;</span>)<br>plt.show() <br></code></pre></div></td></tr></table></figure></li></ul><hr><p>具体的代码我已经放在了<a href="https://github.com/februarysea/wordcloud">这里</a>，欢迎star。</p>]]></content>
    
    
    <categories>
      
      <category>项目记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Crawler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习（一）线性回归</title>
    <link href="/2019/10/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <url>/2019/10/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<p>该系列内容是基于吴恩达老师的<a href="https://www.coursera.org/learn/machine-learning/">机器学习</a>课程笔记。</p><p>参考了<a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes">@fengdu78</a>的课程笔记开源项目。</p><hr><h4 id="监督学习（Supervised-Learning）和非监督学习-Unsupervised-Learning"><a href="#监督学习（Supervised-Learning）和非监督学习-Unsupervised-Learning" class="headerlink" title="监督学习（Supervised Learning）和非监督学习(Unsupervised Learning)"></a>监督学习（Supervised Learning）和非监督学习(Unsupervised Learning)</h4><ul><li><p>监督学习：对于监督学习中的每一个样本，我们已经被清楚地告知了，什么是所谓的正确答案，对于预测肿瘤来说，样本病人年龄等参数和肿瘤是良性还是恶性已经确定，对于预测房价来说，样本的房屋面积等参数对应的房价是确定的。我们算法通过找到最符合样本的一个函数。通过这个函数来预测其他情况。</p><p><img src="https://github.com/februarysea/picbed/blob/master/supervised.png?raw=true"></p><p><img src="https://github.com/februarysea/picbed/blob/master/supervisedlearning2.png?raw=true"></p></li><li><p>无监督学习：在无监督学习中，没有属性或标签这一概念，也就是说所有的数据，都是一样的。我们要依靠算法把相似的数据样本放到一起，把不同的样本区分开。比如，许多公司拥有庞大的客户信息数据库，那么给你一个客户数据集，你能否自动找出不同的市场分割，并自动将你的客户分到不同的细分市场中，从而有助于我在不同的细分市场中进行更有效的销售。我们现在有这些客户数据，但我们预先并不知道有哪些细分市场，而且，对于我们数据集的某个客户，我们也不能预先知道，谁属于细分市场一，谁又属于细分市场二等等，但我们必须让这个算法自己去从数据中发现这一切。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/0c93b5efd5fd5601ed475d2c8a0e6dcd.png"></p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/94f0b1d26de3923fc4ae934ec05c66ab.png"></p></li></ul><h3 id="单变量线性回归（Linear-Regression-with-One-Variable）"><a href="#单变量线性回归（Linear-Regression-with-One-Variable）" class="headerlink" title="单变量线性回归（Linear Regression with One Variable）"></a>单变量线性回归（Linear Regression with One Variable）</h3><p>我们将要用来描述这个回归问题的标记如下:</p><p>$m$ 代表训练集中实例的数量</p><p>$x$ 代表特征&#x2F;输入变量</p><p>$y$ 代表目标变量&#x2F;输出变量</p><p>$\left( x,y \right)$ 代表训练集中的实例</p><p>$({ {x}^{(i)} },{ {y}^{(i)} })$ 代表第$i$ 个观察实例</p><p>$h$ 代表学习算法的解决方案或函数也称为假设（<strong>hypothesis</strong>）</p><p>一种可能的表达方式为：$h_\theta \left( x \right)&#x3D;\theta_{0} + \theta_{1}x$，因为只含有一个特征&#x2F;输入变量，因此这样的问题叫作单变量线性回归问题。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/H6qTdZmYEeaagxL7xdFKxA_2f0f671110e8f7446bb2b5b2f75a8874_Screenshot-2016-10-23-20.14.58.png"></p><p>为了预测尽可能的精确，我们使预测值$h_\theta \left( x \right)$和实际值$y$之间的差距尽可能的小，即 求代价函数<strong>（Cost Function）</strong>：$J \left( \theta_0, \theta_1 \right) &#x3D; \frac{1} {2m}\sum\limits_{i&#x3D;1}^m \left( h_{\theta}(x^{(i)})-y^{(i)} \right)^{2}$的最小值。其中，指数上的$2$是为了防止出现负值，$\frac{1} {2m}$是为了后面的梯度下降法计算方便。</p><ul><li><p><strong>梯度下降法</strong></p><p>使用梯度下降法求解代价函数$J \left( \theta_0, \theta_1 \right) &#x3D; \frac{1} {2m}\sum\limits_{i&#x3D;1}^m \left( h_{\theta}(x^{(i)})-y^{(i)} \right)^{2}$的最小值，</p><p>主要思想是：</p><ol><li>给$ \theta_0, \theta_1$一个初值，通常设为$0$</li><li>改变$ \theta_0, \theta_1$，来减小$J \left( \theta_0, \theta_1 \right)$直到找到$J \left( \theta_0, \theta_1 \right)$的最小值或局部最小值</li></ol><p>梯度下降法的更新规则如下：</p><p>​                                    ${\theta_{j} }:&#x3D;{\theta_{j} }-\alpha \frac{\partial } {\partial {\theta_{j} } }J\left( \theta \right)$，</p><p>其中，$a$是学习率，通常要根据设计算法的工程师的经验去设计。</p><p>如果$a$太小的话，可能会很慢，因为它会一点点挪动，它会需要很多步才能到达全局最低点。如果$a$太大，那么梯度下降法可能会越过最低点，甚至可能无法收敛，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，所以，如果$a$太大，它会导致无法收敛，甚至发散。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/UJpiD6GWEeai9RKvXdDYag_3c3ad6625a2a4ec8456f421a2f4daf2e_Screenshot-2016-11-03-00.05.27.png"></p><p>值得注意的是，每个${\theta_{j} }$都需要同时更新，如图所示。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/yr-D1aDMEeai9RKvXdDYag_627e5ab52d5ff941c0fcc741c2b162a0_Screenshot-2016-11-02-00.19.56.png"></p></li></ul><h3 id="多变量线性回归（Linear-Regression-with-Multiple-Variable）"><a href="#多变量线性回归（Linear-Regression-with-Multiple-Variable）" class="headerlink" title="多变量线性回归（Linear Regression with Multiple Variable）"></a>多变量线性回归（Linear Regression with Multiple Variable）</h3><p>以房价模型为例，现在我们对房价模型增加更多的特征，例如房间数楼层等，构成一个含有多个变量的模型，模型中的特征为$\left( {x_{1} },{x_{2} },…,{x_{n} } \right)$。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/591785837c95bca369021efa14a8bb1c.png"></p><p>增添更多特征后，我们引入一系列新的注释：</p><p>$n$ 代表特征的数量</p><p>${x^{\left( i \right)} }$代表第 $i$ 个训练实例，是特征矩阵中的第$i$行，是一个<strong>向量</strong>（<strong>vector</strong>）。</p><p>比方说，上图的</p><p>${x}^{(2)}\text{&#x3D;}\begin{bmatrix} 1416\ 3\ 2\ 40 \end{bmatrix}$，</p><p>${x}_{j}^{\left( i \right)}$代表特征矩阵中第 $i$ 行的第 $j$ 个特征，也就是第 $i$ 个训练实例的第 $j$ 个特征。</p><p>如上图的$x_{2}^{\left( 2 \right)}&#x3D;3,x_{3}^{\left( 2 \right)}&#x3D;2$，</p><p>支持多变量的假设 $h$ 表示为：$h_{\theta}\left( x \right)&#x3D;{\theta_{0} }+{\theta_{1} } {x_{1} }+{\theta_{2} } {x_{2} }+…+{\theta_{n} } {x_{n} }$，</p><p>这个公式中有$n+1$个参数和$n$个变量，为了使得公式能够简化一些，引入$x_{0}&#x3D;1$，则公式转化为：$h_{\theta} \left( x \right)&#x3D;{\theta_{0} } {x_{0} }+{\theta_{1} } {x_{1} }+{\theta_{2} } {x_{2} }+…+{\theta_{n} } {x_{n} }$</p><p>此时模型中的参数是一个$n+1$维的向量，任何一个训练实例也都是$n+1$维的向量，特征矩阵$X$的维度是 $m*(n+1)$。 因此公式可以简化为：$h_{\theta} \left( x \right)&#x3D;{\theta^{T} }X$，其中上标$T$代表矩阵转置。</p><ul><li><p><strong>多变量梯度下降法</strong></p><p>与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价函数是所有建模误差的平方和，即：$J\left( {\theta_{0} },{\theta_{1} }…{\theta_{n} } \right)&#x3D;\frac{1} {2m}\sum\limits_{i&#x3D;1}^{m} { { {\left( h_{\theta} \left({x}^{\left( i \right)} \right)-{y}^{\left( i \right)} \right)}^{2} } }$ ，</p><p>其中：$h_{\theta}\left( x \right)&#x3D;\theta^{T}X&#x3D;{\theta_{0} }+{\theta_{1} } {x_{1} }+{\theta_{2} } {x_{2} }+…+{\theta_{n} } {x_{n} }$ ，</p><p>我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。 多变量线性回归的批量梯度下降算法为：</p><p>​                                                    ${\theta_{j} }:&#x3D;{\theta_{j} }-\alpha \frac{\partial } {\partial {\theta_{j} } }J\left( \theta_{0},\theta_{1}…\theta_{n}\right) $</p></li><li><p><strong>梯度下降法实践1-特征缩放</strong></p><p>在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛。</p><p>以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为 0-2000平方英尺，而房间数量的值则是0-5，以两个参数分别为横纵坐标，绘制代价函数的等高线图能，看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/966e5a9b00687678374b8221fdd33475.jpg"></p><p>解决的方法是尝试将所有特征的尺度都尽量缩放到-1到1之间。如图：</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/b8167ff0926046e112acf789dba98057.png"></p><p>最简单的方法是令：${ {x} }&#x3D;\frac{ {x}-{\mu} } { {s} }$  ，其中${\mu_{n} }$是平均值，${s_{n} }$是标准差。</p></li><li><p><strong>梯度下降法实践2-学习率</strong></p><p>梯度下降算法的每次迭代受到学习率的影响，如果学习率$a$过小，则达到收敛所需的迭代次数会非常高；如果学习率$a$过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</p><p>通常可以考虑尝试些学习率：</p><p>​                                                        $\alpha&#x3D;0.01，0.03，0.1，0.3，1，3，10$</p></li><li><p><strong>多项式回归</strong></p><p>以房价预测问题为例，现在有如下图所示两个参数。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/8ffaa10ae1138f1873bc65e1e3657bd4.png"></p><p>$h_{\theta}\left( x \right)&#x3D;{\theta_{0} }+{\theta_{1} }\times{frontage}+{\theta_{2} }\times{depth}$</p><p>${x_{1} }&#x3D;frontage$（临街宽度），${x_{2} }&#x3D;depth$（纵向深度），$x&#x3D;frontage*depth&#x3D;area$（面积），则：${h_{\theta} }\left( x \right)&#x3D;{\theta_{0} }+{\theta_{1} }x$。 线性回归并不适用于所有数据，有时我们需要曲线来适应我们的数据，比如一个二次方模型：$h_{\theta}\left( x \right)&#x3D;{\theta_{0} }+{\theta_{1} } {x_{1} }+{\theta_{2} } {x_{2}^2}$ 或者三次方模型： $h_{\theta}\left( x \right)&#x3D;{\theta_{0} }+{\theta_{1} } {x_{1} }+{\theta_{2} } {x_{2}^2}+{\theta_{3} } {x_{3}^3}$</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/3a47e15258012b06b34d4e05fb3af2cf.jpg"></p><p>注：如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。</p></li><li><p><strong>正规方程</strong></p><p>正规方程是通过求解下面的方程来找出使得代价函数最小的参数的：$\frac{\partial}   {\partial{\theta_{j} } }J\left( {\theta_{j} } \right)&#x3D;0$ 。 假设我们的训练集特征矩阵为 $X$（包含了 ${ {x}_{0} }&#x3D;1$）并且我们的训练集结果为向量 $y$，则利用正规方程解出向量： </p><p>​                                                            $\theta &#x3D;{ {\left( {X^T}X \right)}^{-1} } {X^{T} }y$ </p><p>上标<strong>T</strong>代表矩阵转置，上标-1 代表矩阵的逆。</p><p>注：对于那些不可逆的矩阵（通常是因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量），正规方程方法是不能用的。</p><p>梯度下降与正规方程的比较：</p><table><thead><tr><th>梯度下降</th><th>正规方程</th></tr></thead><tbody><tr><td>需要选择学习率$\alpha$</td><td>不需要</td></tr><tr><td>需要多次迭代</td><td>一次运算得出</td></tr><tr><td>当特征数量$n$大时也能较好适用</td><td>需要计算${ {\left( { {X}^{T} }X \right)}^{-1} }$ 如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为$O\left( { {n}^{3} } \right)$，通常来说当$n$小于10000 时还是可以接受的</td></tr><tr><td>适用于各种类型的模型</td><td>只适用于线性模型，不适合逻辑回归模型等其他模型</td></tr></tbody></table><p>总结一下，只要特征变量的数目并不大，正规方程是一个很好的计算参数$\theta $的替代方法。具体地说，只要特征变量数量小于一万，通常使用正规方程法，而不使用梯度下降法。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习使用git</title>
    <link href="/2019/07/07/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8git/"/>
    <url>/2019/07/07/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8git/</url>
    
    <content type="html"><![CDATA[<p>一直在使用<a href="https://github.com/">github</a>，对Git的操作多多少少也知道一些，但一直没有系统的学习过，脑海中是很零散的知识，所以记录一下一些Git的基本概念和操作。</p><h3 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h3><p>Git 把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/20190707212257.png"></p><p> Git 有三种状态：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/20190707212252.png"></p><p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p><p>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作&#96;‘索引’’，不过一般说法还是叫暂存区域。</p><p>基本的 Git 工作流程如下：</p><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ol><h3 id="Git的基本操作"><a href="#Git的基本操作" class="headerlink" title="Git的基本操作"></a>Git的基本操作</h3><h5 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h5><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git init</span><br></code></pre></div></td></tr></table></figure><p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p><h5 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h5><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git add file</span><br></code></pre></div></td></tr></table></figure><p>这样一来，<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区，我们希望提交不同的版本，还需要<code>commit</code>操作：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;commit description&quot;</span></span><br></code></pre></div></td></tr></table></figure><p>后面的参数是<code>commit</code>的改动说明，为了日后方便查看。创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>查看提交记录：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span></span><br></code></pre></div></td></tr></table></figure><p>显示出来是类似这样的形式：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span></span><br>commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)<br>Author: Michael Liao &lt;askxuefeng@gmail.com&gt;<br>Date:   Fri May 18 21:03:36 2018 +0800<br><br>    add distributed<br><br>commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0<br>Author: Michael Liao &lt;askxuefeng@gmail.com&gt;<br>Date:   Fri May 18 20:59:18 2018 +0800<br><br>    wrote a readme file<br><br></code></pre></div></td></tr></table></figure><p>在Git中<code>HEAD</code>表示当前版本，<code>commit</code>后面的一长串字符串是<code>commit id</code>是用<code> SHA-1</code>计算出的校验和，用十六进制表示通俗来说就是版本号。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> -p -2</span><br></code></pre></div></td></tr></table></figure><p><code>-p</code>用来显示每次提交的内容差异。 加上 <code>-2</code> 来仅显示最近两次提交，该选项除了显示基本信息之外，还附带了每次 commit 的变化。 当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span></span><br></code></pre></div></td></tr></table></figure><p><code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --pretty=oneline</span><br></code></pre></div></td></tr></table></figure><p>另外一个常用的选项是 <code>--pretty</code>。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 <code>oneline</code> 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 可以用。</p><p>值得一提的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git 的更新而发生改变：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">&quot;%h - %an, %ar : %s&quot;</span></span><br>ca82a6d - Scott Chacon, 6 years ago : changed the version number<br>085bb3b - Scott Chacon, 6 years ago : removed unnecessary test<br>a11bef0 - Scott Chacon, 6 years ago : first commit<br></code></pre></div></td></tr></table></figure><h5 id="回溯上个版本"><a href="#回溯上个版本" class="headerlink" title="回溯上个版本"></a>回溯上个版本</h5><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git reset --hard HEAD^</span><br></code></pre></div></td></tr></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ascii">┌────┐<br>│HEAD│<br>└────┘<br>   │<br>   └──&gt; ○ append GPL<br>        │<br>        ○ add distributed<br>        │<br>        ○ wrote a readme file<br></code></pre></div></td></tr></table></figure><p>改为指向<code>add distributed</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ascii">┌────┐<br>│HEAD│<br>└────┘<br>   │<br>   │    ○ append GPL<br>   │    │<br>   └──&gt; ○ add distributed<br>        │<br>        ○ wrote a readme file<br></code></pre></div></td></tr></table></figure><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。如果后悔回溯操作的话，使用下面这个命令，查找之前版本的<code>commit id</code>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git reflog</span><br>e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^<br>1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL<br>e475afc HEAD@&#123;3&#125;: commit: add distributed<br>eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file<br></code></pre></div></td></tr></table></figure><p>这个命令记录了每一次Git操作，知道了每一次操作的<code>commit id</code>后使用:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git reset --hard 1094a</span><br></code></pre></div></td></tr></table></figure><p>就能回到那个版本了。注意：版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><h5 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h5><p>查看两次<code>commit</code>的差别： </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git status</span><br></code></pre></div></td></tr></table></figure><p>查看工作区和版本库里面最新版本的区别：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git diff HEAD -- filename</span><br></code></pre></div></td></tr></table></figure><h5 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h5><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git checkout -- filename</span><br></code></pre></div></td></tr></table></figure><p>命令<code>git checkout -- filename</code>意思就是，把文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是文件已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git reset HEAD fliename</span><br></code></pre></div></td></tr></table></figure><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><p>在Git下删除文件使用：</p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> file</span><br></code></pre></div></td></tr></table></figure><h5 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h5><ol><li><p>创建SSH Key</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span></span><br></code></pre></div></td></tr></table></figure><p>在<code>~/.ssh</code>目录下可以看到有<code>id_rsa.pub</code>、 <code>id_rsa</code>分别是公钥和私钥。</p></li><li><p>在GitHub上添加SSH Key</p><p>打开<code>id_rsa.pub</code>复制里面的内容，添加到GitHub上。</p></li><li><p>把项目添加到远程库</p><p>在GitHub上创建一个新的<code>repository</code>。不要创建<code>README.md</code>按照GitHub的提示操作即可。</p></li></ol><h5 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h5><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> git://github.com/februarysea/repository.git</span><br><span class="hljs-meta">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> http://github.com/februarysea/repository.git</span><br></code></pre></div></td></tr></table></figure><p>Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p><hr><p>文章参考了<a href="https://www.liaoxuefeng.com/wiki/896043488029600">@廖雪峰</a>的教程以及<a href="https://git-scm.com/">git官方网站</a>。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于opencv进行人脸识别</title>
    <link href="/2019/07/05/%E5%9F%BA%E4%BA%8Eopencv%E8%BF%9B%E8%A1%8C%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <url>/2019/07/05/%E5%9F%BA%E4%BA%8Eopencv%E8%BF%9B%E8%A1%8C%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>短学期老师教大家用<code>labview</code>编写机器视觉方面的程序，但是这个软件完全是可视化界面，不需要编写程序，我实在没兴趣，和老师申请后用python写了一个简易的人脸识别程序。程序主要有两个部分，第一个部分是获取人脸数据，第二个部分是识别人脸。</p><h3 id="获取人脸数据"><a href="#获取人脸数据" class="headerlink" title="获取人脸数据"></a>获取人脸数据</h3><p>原理是通过<code>oepncv</code>内置的<code>haar</code>算法检测人脸，仅截取人脸部分图片，保存为<code>64*64</code>的png格式图片。<code>png</code>是无损图片压缩，而<code>jpg</code>是有损的，做图像处理当然是无损的好，所以选择<code>png</code>格式。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> os<br><br>out_dir = <span class="hljs-string">&#x27;xxx&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(out_dir):<br>    os.makedirs(out_dir)<br><br><span class="hljs-comment"># 获取分类器</span><br>haar = cv2.CascadeClassifier(<span class="hljs-string">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)<br><br><span class="hljs-comment"># 打开摄像头 参数为输入流，可以为摄像头或视频文件</span><br>camera = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br>n = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">100</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;It`s processing %s image.&#x27;</span> % n)<br>        <span class="hljs-comment"># 读帧</span><br>        success, img = camera.read()<br><br>        <span class="hljs-comment"># 将图像转化为灰度图像</span><br>        gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>        <span class="hljs-comment"># scaleFactor 图像尺寸减小的比例</span><br>        <span class="hljs-comment"># minNeighobrs 目标监测到5次才算真正的目标</span><br>        faces = haar.detectMultiScale(image=gray_img, scaleFactor=<span class="hljs-number">1.3</span>, minNeighbors=<span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">for</span> f_x, f_y, f_w, f_h <span class="hljs-keyword">in</span> faces:<br>            <span class="hljs-comment"># 裁剪 剩下面部</span><br>            face = img[f_y:f_y+f_h, f_x:f_x+f_w]<br>            face = cv2.resize(src=face, dsize=(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>))<br>            cv2.imshow(<span class="hljs-string">&#x27;img&#x27;</span>, face)<br>            <span class="hljs-comment"># png rather than jpg</span><br>            cv2.imwrite(out_dir+<span class="hljs-string">&#x27;/&#x27;</span>+<span class="hljs-built_in">str</span>(n)+<span class="hljs-string">&#x27;.png&#x27;</span>, face)<br>            n += <span class="hljs-number">1</span><br>        key = cv2.waitKey(<span class="hljs-number">30</span>) &amp; <span class="hljs-number">0xff</span><br>        <span class="hljs-keyword">if</span> key == <span class="hljs-number">27</span>:<br>            <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></div></td></tr></table></figure><p>在采集人脸图像上，主要通过<code>opencv</code> 调用电脑的摄像头，人在摄像头下作出不同表情，读取摄像头传输的帧，检测人脸并保存。如下图所示。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB2.png" alt="采集人脸"></p><h3 id="识别人脸"><a href="#识别人脸" class="headerlink" title="识别人脸"></a>识别人脸</h3><p>原理是利用<code>opencv</code>的<code>cv2.face.EigenFaceRecognizer_create()</code>函数，导入人脸数据，进行训练，通过调用返回结果来预测人脸类别，即使用<code>predict()</code>函数，在程序中我只训练了两类，多类的训练方法类似。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LoadImages</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    加载图片数据用于训练</span><br><span class="hljs-string">    params:</span><br><span class="hljs-string">        data:训练数据所在的目录，要求图片尺寸一样</span><br><span class="hljs-string">    ret:</span><br><span class="hljs-string">        images:[m,height,width]  m为样本数，height为高，width为宽</span><br><span class="hljs-string">        names：名字的集合</span><br><span class="hljs-string">        labels：标签</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    images = []<br>    names = []<br>    labels = []<br><br>    label = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 遍历所有文件夹</span><br>    <span class="hljs-keyword">for</span> subdir <span class="hljs-keyword">in</span> os.listdir(data):<br>        <span class="hljs-comment"># os.path.join 路径拼接</span><br>        subpath = os.path.join(data, subdir)<br>        <span class="hljs-comment"># 判断是否是目录</span><br>        <span class="hljs-keyword">if</span> os.path.isdir(subpath):<br>            <span class="hljs-comment"># 在每一个文件夹中存放着一个人的许多照片</span><br>            names.append(subdir)<br>            <span class="hljs-comment"># 遍历文件夹中的图片文件</span><br>            <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> os.listdir(subpath):<br>                <span class="hljs-keyword">if</span> filename.startswith(<span class="hljs-string">&quot;.&quot;</span>):<br>                    <span class="hljs-keyword">continue</span><br>                imgpath = os.path.join(subpath, filename)<br>                img = cv2.imread(imgpath, cv2.IMREAD_COLOR)<br>                gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>                images.append(gray_img)<br>                labels.append(label)<br>            label += <span class="hljs-number">1</span><br>    images = np.asarray(images)<br>    labels = np.asarray(labels)<br>    <span class="hljs-keyword">return</span> images, labels, names<br><br><br><span class="hljs-comment"># 检验训练结果</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">FaceRec</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-comment"># 加载训练的数据</span><br>    X, y, names = LoadImages(data)<br>    model=cv2.face.EigenFaceRecognizer_create()<br>    model.train(X, y)<br><br>    <span class="hljs-comment"># 打开摄像头</span><br>    camera = cv2.VideoCapture(<span class="hljs-number">0</span>)<br>    cv2.namedWindow(<span class="hljs-string">&#x27;faceRecognition&#x27;</span>)<br><br>    <span class="hljs-comment"># 创建级联分类器</span><br>    face_casecade = cv2.CascadeClassifier(<span class="hljs-string">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 读取一帧图像</span><br>        <span class="hljs-comment"># ret:图像是否读取成功</span><br>        <span class="hljs-comment"># frame：该帧图像</span><br>        ret, frame = camera.read()<br>        <span class="hljs-comment"># 判断图像是否读取成功</span><br>        <span class="hljs-comment"># print(&#x27;ret&#x27;,ret)</span><br>        <span class="hljs-keyword">if</span> ret:<br>            <span class="hljs-comment"># 转换为灰度图</span><br>            gray_img = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br><br>            <span class="hljs-comment"># 利用级联分类器鉴别人脸</span><br>            faces = face_casecade.detectMultiScale(gray_img, <span class="hljs-number">1.3</span>, <span class="hljs-number">5</span>)<br><br>            <span class="hljs-comment"># 遍历每一帧图像，画出矩形</span><br>            <span class="hljs-keyword">for</span> (x, y, w, h) <span class="hljs-keyword">in</span> faces:<br>                frame = cv2.rectangle(frame, (x, y), (x + w, y + h), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)  <span class="hljs-comment"># 蓝色</span><br>                roi_gray = gray_img[y:y + h, x:x + w]<br><br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-comment"># 将图像转换为宽64 高64的图像</span><br>                    <span class="hljs-comment"># resize（原图像，目标大小，（插值方法）interpolation=，）</span><br>                    roi_gray = cv2.resize(roi_gray, (<span class="hljs-number">64</span>, <span class="hljs-number">64</span>), interpolation=cv2.INTER_LINEAR)<br>                    params = model.predict(roi_gray)<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Label:%s,confidence:%.2f&#x27;</span> % (params[<span class="hljs-number">0</span>], params[<span class="hljs-number">1</span>]))<br>                    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">                    putText:给照片添加文字</span><br><span class="hljs-string">                    putText(输入图像，&#x27;所需添加的文字&#x27;，左上角的坐标，字体，字体大小，颜色，字体粗细)</span><br><span class="hljs-string">                    &#x27;&#x27;&#x27;</span><br>                    cv2.putText(frame, names[params[<span class="hljs-number">0</span>]], (x, y - <span class="hljs-number">20</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="hljs-number">1</span>, <span class="hljs-number">255</span>, <span class="hljs-number">2</span>)<br>                <span class="hljs-keyword">except</span>:<br>                    <span class="hljs-keyword">continue</span><br><br>            cv2.imshow(<span class="hljs-string">&#x27;人脸识别test&#x27;</span>, frame)<br><br>            <span class="hljs-comment"># 按下esc键退出</span><br>            <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">100</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-number">27</span>:<br>                <span class="hljs-keyword">break</span><br>    camera.release()<br>    cv2.destroyAllWindows()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    data = <span class="hljs-string">&quot;training-data&quot;</span><br>    FaceRec(data)<br></code></pre></div></td></tr></table></figure><p>人脸识别结果，终端输出的是此类的置信度。</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB1.png" alt="人脸识别结果"></p><p>两类样本识别结果：</p><p><img src="https://raw.githubusercontent.com/februarysea/picbed/master/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB3.png" alt="两类样本识别结果 "></p><hr><p>内容参考了<a href="https://www.cnblogs.com/do-hardworking/p/9867708.html">@大大木瓜</a>、<a href="https://www.cnblogs.com/zhuifeng-mayi/p/9171383.html">@追风的小蚂蚁</a>博客的文章。</p>]]></content>
    
    
    <categories>
      
      <category>项目记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos下python3的安装</title>
    <link href="/2019/06/13/centos%E4%B8%8Bpython3%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2019/06/13/centos%E4%B8%8Bpython3%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>服务器中新安装的系统只有<code>python2</code>没有<code>python3</code>，只好自己装<code>python3</code>，下面是过程。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd /usr/bin/<br>ll python*<br></code></pre></div></td></tr></table></figure><p>显示当前<code>python</code>的软链接，需要做的是把<code>python-&gt;python2</code>改为<code>python-&gt;python3</code>，两版本就可以共存。</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">lrwxrwxrwx.<span class="hljs-number"> 1 </span>root root   <span class="hljs-number"> 9 </span>3月  <span class="hljs-number"> 19 </span>2018 python -&gt; python2<br>lrwxrwxrwx.<span class="hljs-number"> 1 </span>root root   <span class="hljs-number"> 9 </span>3月  <span class="hljs-number"> 19 </span>2018 python2 -&gt; python2.7<br>-rwxr-xr-x.<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 7136 </span>8月  <span class="hljs-number"> 4 </span>2016 python2.7<br></code></pre></div></td></tr></table></figure><p>安装编译<code>python3</code>所用到的相关依赖</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make<br></code></pre></div></td></tr></table></figure><p>添加<code>epel</code>扩展源且安装<code>pip</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yum -y install epel-release<br>yum install python-pip<br></code></pre></div></td></tr></table></figure><p>用<code>pip</code>安装<code>wget</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pip install wget<br></code></pre></div></td></tr></table></figure><p>用<code>wget</code>下载<code>python3</code>压缩包</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">wget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tar.xz<br></code></pre></div></td></tr></table></figure><p>解压编译python3压缩包</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="language-bash">解压</span><br>xz -d Python-3.6.4.tar.xz<br>tar -xf Python-3.6.4.tar<br>cd Python-3.6.4<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="language-bash">编译</span><br>./configure prefix=/usr/local/python3<br>make &amp;&amp; make install<br></code></pre></div></td></tr></table></figure><p>如果最后没提示出错，就代表正确安装了，在<code>/usr/local/</code>目录下就会有<code>python3</code>目录。</p><p>把<code>python3</code>的<code>bin</code>添加到环境变量中。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">export PATH=$PATH:/usr/local/python3/bin<br></code></pre></div></td></tr></table></figure><p>删除<code>python-&gt;python2</code>的软链接，添加<code>python3</code>相关的软链接。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="language-bash">删除python-&gt;python2的软链接</span><br>rm /usr/bin/pip /usr/bin/pip.bak<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="language-bash">添加python-&gt;python3的软链接</span><br>ln -s /usr/local/python3/bin/pip3 /usr/bin/pip <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="language-bash">添加pip-&gt;pip3的软链接</span><br>ln -s /usr/local/python3/bin/python3.6 /usr/bin/python<br></code></pre></div></td></tr></table></figure><p><code>python3</code>现在已经可以在Linux服务器下正常使用了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh免密登录</title>
    <link href="/2019/06/12/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
    <url>/2019/06/12/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>There were 2290 failed login attempts since the last successful login.</p></blockquote><p>本来打算使用购买的云服务器直接开始Linux的学习，这次登录上我的云服务器发现了这个提醒，感觉我的服务器非常不安全，于是对我的服务器做了如下设置。</p><span id="more"></span><h4 id="改用ssh证书登录并更改登录端口"><a href="#改用ssh证书登录并更改登录端口" class="headerlink" title="改用ssh证书登录并更改登录端口"></a>改用ssh证书登录并更改登录端口</h4><p> ssh证书认证方式简单的解释是首先在客户端上创建一对公私钥 （公钥文件：<code>~/.ssh/id_rsa.pub</code>； 私钥文件：<code>~/.ssh/id_rsa</code>），然后把公钥放到服务器上（<code>~/.ssh/authorized_keys</code>）, 自己保留好私钥。当ssh登录时,ssh程序会发送私钥去和服务器上的公钥做匹配.如果匹配成功就可以登录了。以下操作仅针对Mac。</p><ul><li><p><strong>生成密钥</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd ~/.ssh<br>ssh-keygen -t rsa<br></code></pre></div></td></tr></table></figure><p>生成后的密钥存放在<code>～/.ssh/</code>目录下生成了2个文件：<code>id_rsa</code>为私钥，<code>id_rsa.pub</code>为公钥。下面的操作均在该目录下进行。</p></li><li><p><strong>发送公钥到服务器</strong></p></li><li><div class="hljs code-wrapper"><pre><code class="shell">ssh-copy-id -i id_rsa.pub root@host <figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey"><br>* **将私钥添加到由`ssh-agent` 维护的列表中**<br><br>  ```shell<br>  ssh-add -K id_rsa<br></code></pre></div></td></tr></table></figure></code></pre></li><li><p><strong>修改config配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"> vim config<br> <br>Host tencent#ssh登录命令<br> hostname host #服务器ip<br>user root #root用户<br> IdentityFile ~/.ssh/id_rsa #是mac上的私钥<br></code></pre></div></td></tr></table></figure></li><li><p><strong>测试是否设置成功</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh tencent<br></code></pre></div></td></tr></table></figure><p>确实可以登录服务器，说明设置成功。</p></li><li><p><strong>更改ssh登录登录端口</strong></p><p>尽管本地电脑可以免密登录，但其他人仍然可以暴力尝试登录，把ssh登录端口号从默认22更改为其他。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">vim /etc/ssh/sshd_config<br>Port 29826<br></code></pre></div></td></tr></table></figure><p>重启服务。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">service sshd restart <br></code></pre></div></td></tr></table></figure><p>新的config文件设置如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Host tencent#ssh登录命令<br>hostname host #服务器ip<br>user root #root用户<br>port 29826#端口号<br>IdentityFile ~/.ssh/id_rsa #是mac上的私钥<br></code></pre></div></td></tr></table></figure><p>这样一来，通过ssh证书指定端口登录，不存在服务器被暴力破解的问题了。</p></li></ul><ul><li><p><strong>添加多个服务器</strong></p><p>使用同一个公钥，将公钥发送到需要添加的服务器端，并在本地<code>config</code>文件添加和上面类似的描述就好了，如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Host tencent                                            <br>hostname hostname<br>user root<br>port 29826<br>IdentityFile ~/.ssh/id_rsa<br>  <br>Host newair<br>hostname hostname<br>user root<br>port 28922<br>IdentityFile ~/.ssh/id_rsa<br></code></pre></div></td></tr></table></figure></li></ul><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/32279976">@dreday</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac下使用Hexo在GitHub上搭建博客</title>
    <link href="/2019/06/07/mac%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8GitHub%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2019/06/07/mac%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8GitHub%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>之前是在vps上用Wordpress搭建的博客，用的是国外的vps，最近一大批IP被block了，我的也没能幸免，加之对之前的博客有种种不满意，索性拿GitHub Page 重新建立了一个博客。</p><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><ul><li><p>安装node.js</p><p>我直接使用 <code>brew install -g node</code>在Mac OS下安装出现了一堆问题，于是转到node官网直接下载安装，很顺利地安装成功了。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">node -v<br>v10.16.0<br>npm -v<br>6.9.0<br></code></pre></div></td></tr></table></figure></li><li><p>安装git</p><p>在macOS Mavericks （10.9） 或更高版本的系统中已经内置了git。确认一下，git确实已经安装。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git --version <br>git version 2.20.1 (Apple Git-117)<br></code></pre></div></td></tr></table></figure></li><li><p>安装Hexo</p><p>把Hexo的依赖安装完成后就可以安装Hexo了。</p><p><code>sudo npm install -g hexo</code></p></li><li><p>创建博客</p><p>安装完成后，创建博客文件夹，用来存放自己的博客数据。进入blog文件夹中。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">mkdir blog<br>cd blog<br></code></pre></div></td></tr></table></figure><p>使用如下命令初始化Hexo博客，安装npm。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">hexo init<br>sudo npm install<br></code></pre></div></td></tr></table></figure><p>新建完成后，blog文件夹下的目录如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br></code></pre></div></td></tr></table></figure><p><strong>_config.yml</strong></p><p>网站的配置信息，可以在里面修改网页的大部分参数。需要注意的是该文件使用的是YAML&#x2F;YML语言。</p><blockquote><p><strong>YAML&#x2F;YML语言</strong></p><ol><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用Tab键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li></ol></blockquote><p><strong>package.json</strong></p><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p><p><strong>scaffolds</strong></p><p>模版文件夹。新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果修改scaffold&#x2F;post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><p><strong>source</strong></p><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><p><strong>themes</strong></p><p>主题文件夹。Hexo 会根据主题来生成静态页面。</p></li><li><p>使用如下命令生成静态文件并启动服务器。s</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">hexo generate   # 可简写为 hexo g<br>hexo server     # 可简写为 hexo s<br></code></pre></div></td></tr></table></figure><p>现在就可以在本地访问网页了，默认情况下网址为<a href="http://localhost:4000/">http://localhost:4000</a>。</p></li></ul><h4 id="本地博客发布到GitHub上"><a href="#本地博客发布到GitHub上" class="headerlink" title="本地博客发布到GitHub上"></a>本地博客发布到GitHub上</h4><p>登录GitHub后创建新的repository，名称为 <code>user.github.io</code>，必须使用自己的用户名。例如<code>februarysea.github.io</code>。</p><p>然后到blog文件夹下，编辑_config.yml文档。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">vim _config.yml<br></code></pre></div></td></tr></table></figure><p>将文档最下面的deploy<code>配置如下。repository将</code>februarysea&#96;替换为自己的用户名。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">deploy:<br>  type: &quot;git&quot;<br>  repository: &#x27;https://github.com/februarysea/februarysea.github.io.git&#x27;<br>  branch: &#x27;master&#x27;<br></code></pre></div></td></tr></table></figure><p>然后生成静态文件，并上传到GitHub服务器。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">hexo g<br>hexo deploy  # 可简写为 hexo -d<br></code></pre></div></td></tr></table></figure><p>若未关联GitHub，执行<code>hexo d</code>时会提示输入GitHub账号用户名和密码，把自己的GitHub账号密码输进去就好了。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">username for &#x27;https://github.com&#x27;:<br>password for &#x27;https://github.com&#x27;:<br></code></pre></div></td></tr></table></figure><p>执行成功后就可以在<a href="februarysea.github.io">februarysea.github.io</a>访问博客了，内容与<a href="http://localhost:4000相同。">http://localhost:4000相同。</a></p><h4 id="选择自己的域名关联GitHub-Page"><a href="#选择自己的域名关联GitHub-Page" class="headerlink" title="选择自己的域名关联GitHub Page"></a>选择自己的域名关联GitHub Page</h4><ul><li><p>购买域名</p><p>现在已经可以通过浏览器输入<a href="februarysea.github.io">februarysea.github.io</a>来访问博客了，但是始终觉得这个域名太长了，一点也不好记，于是决定去买一个好记的域名来关联GitHub Page。进入阿里云的官网后，在搜索框输入域名，并点击域名注册，就可以看到域名查询界面。对于我来说，我仅仅是想要一个个性化的博客域名，所以域名的后缀足够酷就好了，不需追求顶级域名。需要注意的是有一些域名第一年注册很便宜，但是续费却比注册贵的多，购买的时候要看清楚。选择好之后一步步的付款就好了。</p></li><li><p>解析域名</p><p>域名购买后，需要将它与GitHub Page关联。这时候就要用到域名解析。进入阿里云的控制台域名界面，可以看到刚刚购买的域名后面有一个解析，点击之后按如下填写，需要添加两个解析，使得网址前面有没有<code>www</code>都能访问。</p><blockquote><p>记录类型：CNAME<br>主机记录：www<br>解析线路：默认<br>记录值：februarysea.github.io &#x2F;&#x2F;这里替换成自己的网站<br>TTL: 10分钟</p></blockquote><blockquote><p>记录类型：CNAME<br>主机记录：@<br>解析线路：默认<br>记录值：februarysea.github.io &#x2F;&#x2F;这里替换成自己的网站<br>TTL: 10分钟</p></blockquote></li><li><p>将GitHub Page指向域名</p><p>在<code>source</code>文件中添加<code>CNME</code>文件，并在<code>CNAME</code>中写入自己的域名<code>februarysea.com</code>，其它什么也不要写，</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd source<br>vim CNAME<br></code></pre></div></td></tr></table></figure><p>设置完成后执行渲染、部署。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">hexo g<br>hexo d<br></code></pre></div></td></tr></table></figure><p>这样设置完成后，过一会儿就可以通过购买的域名访问自己的网站了。</p></li></ul><hr><p>参考：<a href="https://zhuanlan.zhihu.com/p/34654952">@谓之小一</a></p>]]></content>
    
    
    <categories>
      
      <category>项目记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
